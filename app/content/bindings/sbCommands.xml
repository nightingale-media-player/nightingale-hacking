<?xml version="1.0"?>
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE window SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="commands-base">

    <implementation type="application/x-javascript">

      <constructor>
        <![CDATA[
          this._destroyed = false;
          this._deferRefresh = false;
          this._needRefresh = false;
          this._laststateonly = false;
          // Load up the string bundle
          var src = "chrome://songbird/locale/songbird.properties";
          var stringBundleService =
              Components.classes["@mozilla.org/intl/stringbundle;1"]
              .getService(Components.interfaces.nsIStringBundleService);
          this.stringbundle = stringBundleService.createBundle( src );
          var selfbind = this.getAttribute("bind");
          if (selfbind) {
            var libraryManager =
              Components.classes["@songbirdnest.com/Songbird/library/Manager;1"]
                        .getService(Components.interfaces.sbILibraryManager);
            var guids = selfbind.split(';');
            var libraryguid = guids[0];
            var playlistguid = guids[1];
            var bindtomedialist = null;
            var library = libraryManager.getLibrary(libraryguid);
            if (library) {
              if (libraryguid == playlistguid) bindtomedialist = library;
              else bindtomedialist = library.getMediaItem(playlistguid);
            }
            if (bindtomedialist) {
              this.bind(bindtomedialist, null, null);
            }
          }
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
        this.destroy();
        ]]>
      </destructor>
      
      <method name="destroy">
        <body>
          <![CDATA[
          if (!this._destroyed) {
            this.removeCommands();
            this.emptyCommandsArray();
            this.stringbundle = null;
            this._outerWindow = null;
            this.medialist = null;
            this.playlist = null;
            this.defaultcommands = null;
            this._outerWindow = null;
            try {
              this.destroy2();
            } catch (e) {}
            this._destroyed = true;
          }
        ]]>  
        </body>
      </method>

      <property name="commandtype">
        <getter>
          return this.getAttribute("commandtype");
        </getter>
        <setter>
          this.setAttribute("commandtype", val);
        </setter>
      </property>

      <field name="commands">null</field>
      <field name="playlist">null</field>
      <field name="medialist">null</field>
      <field name="hoststring">"generic"</field>

      <field name="_outerWindow">null</field>
      <property name="outerWindow">
        <getter>
          <![CDATA[
            return this._outerWindow;
          ]]>
        </getter>
        <setter>
          <![CDATA[
            return this._outerWindow = val;
          ]]>
        </setter>
      </property>

      <property name="usedefault">
        <getter>
          return (this.getAttribute("usedefault") != "false");
        </getter>
        <setter>
          <![CDATA[
            var old = this.usedefault;
            this.setAttribute("usedefault", val);
            if (this.commands && this.usedefault != old) {
              this.rescanCommands();
            }
          ]]>
        </setter>
      </property>
      
      <method name="bind">
        <parameter name="medialist"/>
        <parameter name="playlist"/>
        <parameter name="commands"/>
        <body>
        <![CDATA[
          try {
            this.medialist = medialist;
            this.playlist = playlist;
            this.defaultcommands = commands ? commands.duplicate() : null; 
            this.rescanCommands();
          } catch (e) {
              alert( "sbCommands.xml - bind - " + e );
          }
        ]]>
        </body>
      </method>
      
      <method name="emptyCommandsArray">
        <body>
          <![CDATA[
            if (this.commands) {
              for (var i in this.commands) {
                var cmd = this.commands[i];
                cmd.shutdownCommands();
              }
            }
            this.commands = new Array();
          ]]>
        </body>
      </method>
      <method name="rescanCommands">
        <body>
          <![CDATA[
            if (this.medialist) {
              //alert("rescanCommands for " + this.hoststring + " - " + this.medialist.name);
              this.emptyCommandsArray();
              var source = Components.classes["@songbirdnest.com/Songbird/PlaylistCommandsManager;1"]
                                    .getService(Components.interfaces.sbIPlaylistCommandsManager);
              var cmds;
              switch (this.commandtype) {
                case "medialist":
                  cmds = source.getPlaylistCommandsMediaList( this.medialist.guid, this.medialist.type );
                  break;
                // default case
                case "mediaitem":
                case "":
                default:
                  cmds = source.getPlaylistCommandsMediaItem( this.medialist.guid, this.medialist.type );
                  break;
              }
              if ( cmds )
              {
                while (cmds.hasMoreElements()) {
                  var obj = cmds.getNext();
                  // Make sure the object does what we think it does.
                  obj = obj.QueryInterface( Components.interfaces.sbIPlaylistCommands );
                  // add it to our array
                  if (obj) {
                    obj.initCommands(this.hoststring);
                    this.commands.push(obj);
                  }
                }
              }
              
              // Use the defaults only if allowed and if we didnt get anything so far
              if (this.usedefault && !this.commands.length) {
                // add the default (generic) command object if specified
                if (this.defaultcommands) {
                  this.defaultcommands.initCommands(this.hoststring);
                  this.commands.push(this.defaultcommands);
                }
              }
              this.refreshCommands();
            }
          ]]>
        </body>
      </method>

      <method name="setDeferRefresh">
        <body>
          <![CDATA[
            try
            {
              this._deferRefresh = true;
            }
            catch( err )
            {
              alert( "sbCommands.xml - setDeferRefresh - " + err );
            }
          ]]>
        </body>
      </method>

      <method name="clearDeferRefresh">
        <body>
          <![CDATA[
            try
            {
              this._deferRefresh = false;
              if (this._needRefresh)
                this.refreshCommands(false);
            }
            catch( err )
            {
              alert( "sbCommands.xml - clearDeferRefresh - " + err );
            }
          ]]>
        </body>
      </method>

      <method name="refreshCommands">
        <parameter name="stateonly"/>
        <body>
          <![CDATA[
            var skip = false;

            // Sometimes we get here before the tree is properly built.  That's bad.
            // Also skip if the playlist is not visible, or if our context has not
            // yet been given a playlist at all.

            try
            {
            if (this.playlist) {
              // safety test, is the playlist ready ?
              var err = false;
              try {
                var a = this.playlist.tree.currentIndex;
              } catch (e) {
                skip=true;
              }
            }
            if (!this.medialist) skip = true;
            if (this.playlist) {
              if (this.playlist.getAttribute("hidden") == "true" ||
                  !this.playlist.mediaListView ||
                  !this.playlist.mediaListView.treeView) {
                skip = true;
              }
            }
            if (skip)
            {
              // So if we're supposed to build the items here, remember that for next time.
              if (!stateonly)
                this._laststateonly = false;
              return;
            }
            // And build them the next time it's time to refresh (this function gets called alot)
            if (!this._laststateonly)
            {
              stateonly = false;
              this._laststateonly = true;
            }
            
            // Convert null to bool.
            if (!stateonly)
              stateonly = false;
              
            // If our internal objects are out of sync, rebuild.
            var forcerebuild = false;
            try {
              forcerebuild = this.shouldForceRebuild();
            } catch (e) { }
            if (forcerebuild)
              stateonly = false;

            // If deferring refresh, skip it
            if ( this._deferRefresh )
            {
              // make a note that we need to refresh when the popup goes away
              this._needRefresh = true;
              // So if we're supposed to build the items here, remember that and quit.
              if (!stateonly)
                this._laststateonly = false;
              return;
            }
            this._needRefresh = false;

            // tell the commands about their context
            if (!stateonly && this.commands) {
              // Once we get here, tell the commands who we are.
              var wnd = this.outerWindow;
              if (!wnd) wnd = window;
              var context = {
                medialist: this.medialist,
                playlist: this.playlist,
                window: wnd,
                commands: null,
                QueryInterface: function(iid) {
                  if (iid.equals(Components.interfaces.sbIPlaylistCommandsContext) || 
                      iid.equals(Components.interfaces.nsISupports))
                    return this;
                  throw Components.results.NS_ERROR_NO_INTERFACE;
                }
              };
              for (var i in this.commands) {
                context.commands = this.commands[i];
                this.commands[i].setContext( context );
              }
            }

            this.doRefreshCommands(stateonly);
          }
          catch( err )
          {
            alert( "sbCommands.xml - refreshCommands - " + this.hoststring + " - " + err );
          }
          ]]>
        </body>
      </method>

      <method name="removeCommands">
        <body>
          <![CDATA[
          try {
            this.doRemoveCommands();
          } catch (e) {
            alert( "sbCommands.xml - doRemoveCommands not implemented ? - " + e );
          }
        ]]>
        </body>
      </method>

      <method name="hasCommands">
        <body>
          <![CDATA[
            if (!this.commands) return false;
            for (var i in this.commands) {
              if (this.commands[i].getNumCommands("", this.hoststring) > 0) return true;
            }
            return false;
          ]]>
        </body>
      </method>

      <method name="translateEntity">
        <parameter name="str"/>
        <body>
          <![CDATA[
            if ( str && str.length > 0 )
            {
              if ( str[ 0 ] == "&" )
              {
                try
                {
                  str = this.stringbundle.GetStringFromName( str.substr( 1, str.length ) );
                }
                catch( err )
                {
                  dump("error playlist.xml translateEntity() - getStringFromName for '" + str + "': " + err + "\n");
                }
              }
            }
            return str;
          ]]>
        </body>
      </method>

      <method name="reportMetrics">
        <parameter name="cmdid"/>
        <body>
          <![CDATA[
            var metricscategory = this.getAttribute("metricscategory");
            if (!metricscategory) return;
            var library = this.medialist ? this.medialist.library : null;
            var metricstype = library ? library.getProperty("http://songbirdnest.com/data/1.0#customType") : null;
            if (!metricstype) return;
            metrics_inc(metricscategory, metricstype, cmdid);
          ]]>
        </body>
      </method>


    </implementation>
 
  </binding>




  <!-- COMMANDS TOOLBAR -->




  <binding id="commands-toolbar" extends="chrome://songbird/content/bindings/sbCommands.xml#commands-base">
  
    <content>
      <xul:hbox id="sb-commands-toolbar-bkg" class="sb-commands-toolbar-bkg" sbid="background" flex="1">
        <xul:hbox id="sb-commands-toolbar" class="sb-commands-toolbar" sbid="parent" flex="1" oncommand="onToolbarCommand( event )" style="h-overflow: hidden;">
        </xul:hbox>
      </xul:hbox>
    </content>

    <implementation type="application/x-javascript">

    <field name="parent">document.getAnonymousElementByAttribute(this, 'sbid', 'parent');</field>
    <field name="toolbarbuttons">new Array();</field>
    <field name="hoststring">"toolbar"</field>

    <method name="shouldForceRebuild">
      <body>
        // If our internal objects are out of sync, rebuild.
        return (this.toolbarbuttons.length == 0); 
      </body>
    </method>
    
    <method name="doRefreshCommands">
      <parameter name="stateonly"/>
      <body>
        <![CDATA[
        try
        {
          if (!stateonly) {
            this.hidden = true;
            this.removeCommands();
          }
          
          if ( this.commands )
          {
            for (var i in this.commands) {
              this.refreshCommandItems(this.commands[i], stateonly, null, this.parent, null, 0, false);
            }
            if (this.toolbarbuttons.length) {
              // If we have items, show the toolbar
              this.hidden = false;
            }
          }
        }
        catch( err )
        {
          alert( "sbCommands.xml - toolbar - doRefreshCommands - " + err );
        }
        ]]>
      </body>
    </method>

    
    <method name="refreshCommandItems">
      <parameter name="cmdobject"/>
      <parameter name="stateonly"/>
      <parameter name="menu"/>
      <parameter name="parentnode"/>
      <parameter name="before"/>
      <parameter name="depth"/>
      <parameter name="radioitems"/>
      <body>
        <![CDATA[
          var toolbarbutton;
          try {
            if (!cmdobject.getVisible(this.hoststring)) return;
            // And make all the new stuff
            var num = cmdobject.getNumCommands(menu, this.hoststring);
            if (stateonly) num = this.toolbarbuttons.length;
            for ( var i = 0; i < num; i++ )
            {
              // skip ?
              if (!stateonly && !cmdobject.getCommandVisible( menu, i, this.hoststring )) {
                //alert("toolbar - item " + i + " not visible: " + cmdobject.getCommandId( menu, i, this.hoststring ));
                continue;
              }
              
              var obj_type;
              toolbarbutton = null;
              if (!stateonly)
              {
                if (radioitems) obj_type = "choiceitem";
                else obj_type = cmdobject.getCommandType( menu, i, this.hoststring );

                // What id?
                var obj_id = cmdobject.getCommandId( menu, i, this.hoststring );
                
                var toolbarbutton_type;
                var toolbarbutton_typeattr = null;
                if (radioitems) toolbarbutton_typeattr = "checkbox";
                var custom = false;
                
                var subobject = cmdobject.getCommandSubObject( menu, i, this.hoststring );
                if (subobject) {
                  this.refreshCommandItems(subobject, stateonly, menu, parentnode, before, depth, false);
                  continue;
                }
                
                if (menu && menu != "") {
                  switch (obj_type) {
                    case "custom": 
                    case "value":
                      // ignore this item
                      toolbarbutton_type = null;
                      break;
                    case "separator":
                      toolbarbutton_type = "menuseparator";
                      break;
                    case "submenu":
                    case "choice":
                      if (depth == 0) toolbarbutton_type = "menupopup";
                      else toolbarbutton_type = "menu";
                      break;
                    case "flag":
                    case "choiceitem":
                      toolbarbutton_typeattr = "checkbox";
                      // Fallthru
                    case "action":
                    default:
                      toolbarbutton_type = "menuitem";
                      break;
                  }
                } else {
                  switch (obj_type) {
                    case "custom": 
                      custom = true;
                      break;
                    case "separator":
                      toolbarbutton_type = "spacer";
                      break;
                    case "choice":
                      toolbarbutton_type = "menulist";
                      break;
                    case "submenu":
                      toolbarbutton_type = "toolbarbutton";
                      toolbarbutton_typeattr = "menu";
                      break;
                    case "value":
                      toolbarbutton_type = "textbox";
                      break;
                    case "flag":
                    case "choiceitem":
                      toolbarbutton_typeattr = "checkbox";
                      // Fallthru
                    case "action":
                    default:
                      toolbarbutton_type = "toolbarbutton";
                      break;
                  }
                }
              
                if (!toolbarbutton_type && !custom) continue;
                                
                // Create a toolbarbutton
                if (custom) {
                  toolbarbutton = cmdobject.instantiateCustomCommand(menu, i, this.hoststring, obj_id, document);
                } else {
                  toolbarbutton = document.createElement( toolbarbutton_type );
                }
                if (!toolbarbutton) continue;
                var label = toolbarbutton;
                var topelement = toolbarbutton;
                toolbarbutton.setAttribute( "id", obj_id );
                if (toolbarbutton_type == "menuitem") { toolbarbutton.setAttribute( "class", "menuitem-iconic" ); } // Icons are set in the css using the id
                if (toolbarbutton_typeattr) toolbarbutton.setAttribute( "type", toolbarbutton_typeattr ); 
                if (toolbarbutton_type == "textbox") {
                  var hbox = document.createElement("hbox");
                  var textlabel = document.createElement("label");
                  var separator = document.createElement("spacer");
                  hbox.setAttribute("align", "center");
                  hbox.appendChild(textlabel);
                  hbox.appendChild(separator);
                  hbox.appendChild(toolbarbutton);
                  toolbarbutton.setAttribute("value", "");
                  toolbarbutton.setAttribute( "sbtype", "command-textbox" ); // to find it easily, later
                  topelement = hbox;
                  label = textlabel;
                }

                topelement.setAttribute( "sbtype", "command" ); // to find it easily, later
                if (!custom) {
                  // No label unless you have a label
                  var cmd_text = cmdobject.getCommandText( menu, i, this.hoststring );
                  if ( cmd_text.length > 0 )
                  {
                    cmd_text = this.translateEntity(cmd_text);
                    if (label.tagName == "label") label.setAttribute( "value", cmd_text+":");
                    else if (label.tagName == "menulist") { /*do nothing*/ }
                    else label.setAttribute( "label", cmd_text );
                  }

                  var cmd_flex = false;
                  if (toolbarbutton_type != "menu" && toolbarbutton_type != "menuitem") cmd_flex = cmdobject.getCommandFlex( menu, i, this.hoststring );
                  
                  if ( cmd_flex > 0 )
                  {
                    toolbarbutton.setAttribute( "flex", cmd_flex );
                  }

                  // No tooltip unless you have a tooltip
                  var tooltip_text = cmdobject.getCommandToolTipText( menu, i, this.hoststring );
                  if ( tooltip_text.length > 0 )
                  {
                    tooltip_text = this.translateEntity(tooltip_text);
                    /*
                        This causes the crashy if it's up while updating.  :(
                    
                      toolbarbutton.setAttribute( "tooltiptext", tooltip_text );
                    */
                  }
                }
                
                toolbarbutton.commandtype = obj_type;
                toolbarbutton.commanddepth = depth;
                toolbarbutton.commandmenu = menu;
                toolbarbutton.commandindex = i;
                toolbarbutton.commandobject = cmdobject;
                toolbarbutton.commandcustom = custom;
              }
              else
              {
                toolbarbutton = this.toolbarbuttons[i];
                obj_type = toolbarbutton.commandtype;
                cmdobject = toolbarbutton.commandobject;
              }

              if ( cmdobject.getCommandEnabled( toolbarbutton.commandmenu, toolbarbutton.commandindex, this.hoststring ) )
              {
                toolbarbutton.removeAttribute( "disabled" );
              }
              else
              {
                toolbarbutton.setAttribute( "disabled", "true" );
              }

              // Add it to the parent
              if (!stateonly)
              {
                this.toolbarbuttons.push( toolbarbutton );
                if (obj_type == "submenu" || obj_type == "choice") {
                  var parent = toolbarbutton;
                  var menupopup = document.createElement("menupopup");
                  menupopup.setAttribute("sbtype", "command");
                  toolbarbutton.appendChild(menupopup);
                  if (!before) parentnode.appendChild(topelement);
                  else parentnode.insertBefore( topelement, before);
                  parent = menupopup;
                  this.refreshCommandItems(cmdobject, stateonly, cmdobject.getCommandId(menu, i, this.hoststring), parent, null, depth+1, (obj_type == "choice"));
                } else {
                  if (!before) parentnode.appendChild(topelement);
                  else parentnode.insertBefore( topelement, before);
                }
              }
              
              if (toolbarbutton.commandtype == "flag") {
                toolbarbutton.setAttribute("checked", cmdobject.getCommandFlag( toolbarbutton.commandmenu, toolbarbutton.commandindex, this.hoststring ));
              }

              if (toolbarbutton.commandtype == "value") {
                var val = cmdobject.getCommandValue( toolbarbutton.commandmenu, toolbarbutton.commandindex, this.hoststring );
                toolbarbutton.value = val;
              }
              if (toolbarbutton.commandtype == "choiceitem") {
                if (toolbarbutton.commanddepth > 1) {
                  toolbarbutton.setAttribute("checked", cmdobject.getCommandChoiceItem( toolbarbutton.commandmenu, this.hoststring ) == toolbarbutton.id);
                } else {
                  if (cmdobject.getCommandChoiceItem( toolbarbutton.commandmenu, this.hoststring ) == toolbarbutton.id) {
                    var e = toolbarbutton;
                    while (e && e.tagName != "menulist") { e = e.parentNode; }
                    if (e) e.selectedIndex = toolbarbutton.commandindex;
                  }
                }
              }
              if (toolbarbutton.commandcustom) {
                cmdobject.refreshCustomCommand(toolbarbutton.commandmenu, toolbarbutton.commandindex, this.hoststring, toolbarbutton.id, toolbarbutton);
              }
            }
          } catch (e) {
            var id="";
            if (toolbarbutton) {
              id = "- " + cmdobject.getCommandId(menu, toolbarbutton.commandindex, this.hoststring) + " ";
            }
            alert("sbCommands.xml - toolbar - refreshCommandItems " + id + e);
          }
        ]]>
      </body>
    </method>

    <method name="doRemoveCommands">
      <body>
        <![CDATA[
          try {
            // Delete the toolbar commands
            var command_nodes = this.parent.getElementsByAttribute( 'sbtype', 'command' );
            // command_nodes is a live array, removing children from parent auto removes items from it
            while ( command_nodes.length > 0 ) 
            {
              var node = command_nodes.item( 0 );
              this.parent.removeChild(node);
            }
            this.toolbarbuttons.length = 0; // clear the array??
          } catch (e) {
            alert("sbCommands.xml - toolbar - " + e);
          }
        ]]>
      </body>
    </method>

    <method name="onToolbarCommand">
      <parameter name="evt"/>
      <body>
        <![CDATA[
        try
        {
          if ( this.commands )
          {
            if (!this.parentNode) return;
            
            var cmdobject = evt.originalTarget.commandobject;
            if (!cmdobject) return;

            this.reportMetrics(evt.originalTarget.id);

            cmdobject.onCommand(evt.originalTarget.commandmenu, 
                                evt.originalTarget.commandindex, 
                                this.hoststring,
                                evt.originalTarget.id,
                                null);

            var type = evt.originalTarget.commandtype;
            if (type == "flag" || type == "choiceitem") this.refreshCommands(true);
          }
        }
        catch( err )
        {
          alert( "sbCommands.xml - toolbar - onToolbarCommand - " + err );
        }
      ]]>
      </body>
    </method>

    </implementation>
    
    <handlers>
      <handler event="keypress">
        <![CDATA[
        try
        {
          var element = event.originalTarget;
          if (event.keyCode == 13 && element.tagName == "html:input") {
            while (1) {
              var sbtype = element.getAttribute("sbtype");
              if (sbtype == "command-textbox") break;
              else if (sbtype && sbtype != "") return;
              element = element.parentNode;
            }

            this.reportMetrics(element.id);

            var cmdobject = element.commandobject;
            if (!cmdobject) return;
            cmdobject.onCommand(element.commandmenu, 
                                element.commandindex, 
                                this.hoststring,
                                element.id,
                                element.value);
          }
        }
        catch( err )
        {
          alert( err )
        }
        ]]>
      </handler>
    </handlers>
 
  </binding>




  <!-- COMMANDS POPUP -->




  <binding id="commands-menuitems" extends="chrome://songbird/content/bindings/sbCommands.xml#commands-base">

    <implementation type="application/x-javascript">
    
    <constructor>
      // hide the binding (this does not hide the items, just the binding)
      this.hidden = true;
    </constructor>
    
    <field name="menuitems">new Array();</field>
    <field name="hoststring">"menu"</field>
    
    <method name="destroy2">
      <body>
        this.resetParentPopup();
      </body>
    </method>

    <method name="shouldForceRebuild">
      <body>
        // If our internal objects are out of sync, rebuild.
        return (this.menuitems.length == 0);
      </body>
    </method>

    <method name="getParentPopup">
      <body>
        <![CDATA[
          var e = this;
          while (e && e != document) {
            if (e.tagName == "popup" || e.tagName == "xul:popup" ||
                e.tagName == "menupopup" || e.tagName == "xul:menupopup") return e;
            e = e.parentNode;
          }
          return null;
        ]]>
      </body>
    </method>
    
    <method name="resetParentPopup">
      <body>
        if (this.parentpopup) {
          if (this.oncommand) {
            this.parentpopup.removeEventListener("command", this.oncommand, false);
            this.oncommand._that = null;
            this.oncommand = null;
          }
          if (this.domnoderemoved) {
            this.removeEventListener("DOMNodeRemoved", this.domnoderemoved, false);
            this.domnoderemoved._that = null;
            this.domnoderemoved = null;
          }
        }
      </body>
    </method>

    <method name="doRefreshCommands">
      <parameter name="stateonly"/>
      <body>
        <![CDATA[
        try
        {
          if (!stateonly) {
            this.removeCommands();
          }

          if ( this.commands )
          {
            var popup = this.getParentPopup();
            if (!this.parentpopup) {
              this.parentpopup = popup;
              this.oncommand = { 
                _that: null, 
                handleEvent: function( event ) { this._that.onMenuCommand(event); } 
              }; this.oncommand._that = this; 
              popup.addEventListener("command", this.oncommand, false);
              this.domnoderemoved = { 
                _that: null, 
                handleEvent: function( event ) { this._that.resetParentPopup(event); } 
              }; this.domnoderemoved._that = this; 
              this.addEventListener("DOMNodeRemoved", this.domnoderemoved, false);
            }
            var before = this;
            
            if (popup) {
              for (var i in this.commands) {
                this.refreshCommandItems(this.commands[i], stateonly, null, popup, before, 0, false);
              }
            }
          }
        }
        catch( err )
        {
          alert( "sbCommands.xml - popup - doRefreshCommands - " + err );
        }
        ]]>
      </body>
    </method>
    
    <method name="refreshCommandItems">
      <parameter name="cmdobject"/>
      <parameter name="stateonly"/>
      <parameter name="menu"/>
      <parameter name="parentnode"/>
      <parameter name="before"/>
      <parameter name="depth"/>
      <parameter name="radioitems"/>
      <body>
        <![CDATA[
          var menuitem;
          try {
            if (!cmdobject.getVisible(this.hoststring)) return;
            // And make all the new stuff
            var num = cmdobject.getNumCommands(menu, this.hoststring);
            if (stateonly) num = this.menuitems.length;
            for ( var i = 0; i < num; i++ )
            {
              menuitem = null;

              // skip ?
              if (!stateonly && !cmdobject.getCommandVisible( menu, i, this.hoststring )) continue;

              // What type?
              var obj_type;

              if (!stateonly)
              {
                if (radioitems) obj_type = "choiceitem";
                else obj_type = cmdobject.getCommandType( menu, i, this.hoststring );

                // What id?
                var obj_id = cmdobject.getCommandId( menu, i, this.hoststring );

                var subobject = cmdobject.getCommandSubObject( menu, i, this.hoststring );
                if (subobject) {
                  this.refreshCommandItems(subobject, stateonly, menu, parentnode, before, depth, false);
                  continue;
                }
                
                var menuitem_type;
                
                switch (obj_type) {  
                  case "separator":
                    menuitem_type = "menuseparator";
                    break;
                  case "submenu":
                  case "choice":
                    menuitem_type = "menu";
                    break;
                  case "custom":
                  case "value":
                    menuitem_type = "";
                    break;
                  case "action":
                  case "choiceitem":
                  case "flag":
                  default:
                    menuitem_type = "menuitem";
                    break;
                }
                
                if (menuitem_type == "") continue;
              
                // And a menuitem
                menuitem = document.createElement( menuitem_type );
                menuitem.setAttribute( "id", obj_id );
                menuitem.setAttribute( "sbtype", "command" );
                menuitem.setAttribute( "class", "menuitem-iconic" ); // Icons are set in the css using the id
                if (obj_type == "flag" || radioitems) menuitem.setAttribute("type", "checkbox");
                
                // No label unless you have a label
                var cmd_text = cmdobject.getCommandText( menu, i, this.hoststring );
                if ( cmd_text.length > 0 )
                {
                  cmd_text = this.translateEntity(cmd_text);
                  menuitem.setAttribute( "label", cmd_text );
                }
                //dump("i = " + i + ", n = " + num + ", - " + cmd_text+"\n");

                // No tooltip unless you have a tooltip
                var tooltip_text = cmdobject.getCommandToolTipText( menu, i, this.hoststring );
                if ( tooltip_text.length > 0 )
                {
                  tooltip_text= this.translateEntity(tooltip_text);
                  /*
                      This causes the crashy if it's up while updating.  :(
                  
                    menuitem.setAttribute( "tooltiptext", tooltip_text );
                  */
                }
                
                menuitem.commandtype = obj_type;
                menuitem.commandmenu = menu;
                menuitem.commandindex = i;
                menuitem.commandobject = cmdobject;
              }
              else
              {
                menuitem = this.menuitems[i];
                menu = menuitem.commandmenu;
                obj_type = menuitem.commandtype;
                cmdobject = menuitem.commandobject;
              }

              if ( cmdobject.getCommandEnabled( menuitem.commandmenu, menuitem.commandindex, this.hoststring ) )
                menuitem.setAttribute( "disabled", "false" );
              else
                menuitem.setAttribute( "disabled", "true" );
                
              if (menuitem.commandtype == "flag") {
                menuitem.setAttribute("checked", cmdobject.getCommandFlag( menuitem.commandmenu, menuitem.commandindex, this.hoststring ));
              }
              if (menuitem.commandtype == "choiceitem") {
                menuitem.setAttribute("checked", (menuitem.id == cmdobject.getCommandChoiceItem( menuitem.commandmenu, this.hoststring )));
              }
              
              // Add it to the parent
              if (!stateonly)
              {
                this.menuitems.push( menuitem );
                if (obj_type == "submenu" || obj_type == "choice") {
                  var menupopup = document.createElement("menupopup");
                  menupopup.setAttribute("sbtype", "command");
                  menuitem.appendChild(menupopup);
                  if (!before) parentnode.appendChild(menuitem);
                  else parentnode.insertBefore( menuitem, before);
                  if (cmdobject.getCommandId(menu, i, this.hoststring) == null) {
                    alert("null submenu: menu = " + menu + ", index = " + i);
                  }
                  this.refreshCommandItems(cmdobject, stateonly, cmdobject.getCommandId(menu, i, this.hoststring), menupopup, null, depth+1, (obj_type == "choice"));
                } else {
                  if (!before) parentnode.appendChild(menuitem);
                  else parentnode.insertBefore( menuitem, before);
                }
              }
            }
          } catch (e) {
            var id="";
            if (menuitem) {
              id = "- " + cmdobject.getCommandId(menu, menuitem.commandindex, this.hoststring) + " ";
            }
            alert("sbCommands.xml - popup - refreshCommandItems " + id + e);
          }
        ]]>
      </body>
    </method>

    <method name="doRemoveCommands">
      <body>
        <![CDATA[
          try {
            // Delete the popup commands
            var popup = this.getParentPopup();
            if (popup) {
              var command_nodes = popup.getElementsByAttribute( 'sbtype', 'command' );
              while ( command_nodes.length > 0 ) 
              {
                var node = command_nodes.item( 0 );
                popup.removeChild(node);
              }
              this.menuitems.length = 0; // clear the array??
            }
          } catch (e) {
            alert("sbCommands.xml - popup - " + e);
          }
        ]]>
      </body>
    </method>

    <method name="onMenuCommand">
      <parameter name="evt"/>
      <body>
        <![CDATA[
        try
        {
          if ( this.commands )
          {
            var cmdobject = evt.originalTarget.commandobject;
            if (!cmdobject) return;
            
            this.reportMetrics(evt.originalTarget.id);

            cmdobject.onCommand(evt.originalTarget.commandmenu, 
                                evt.originalTarget.commandindex, 
                                this.hoststring,
                                evt.originalTarget.id,
                                null);
            var type = evt.originalTarget.commandtype;
            if (type == "flag" || type == "choiceitem") this.refreshCommands(true);
          }
        }
        catch( err )
        {
          alert( "sbCommands.xml - menu - onMenuCommand - " + err );
        }
      ]]>
      </body>
    </method>


    </implementation>
 
  </binding>




  <!-- COMMANDS SHORTCUTS -->




  <binding id="commands-shortcuts" extends="chrome://songbird/content/bindings/sbCommands.xml#commands-base">

    <content>
      <xul:sb-dynamic-keyset sbid="keyset"/>
    </content>

    <implementation type="application/x-javascript">
    
    <constructor>
    </constructor>
    
    <method name="destroy2">
      <body>
      <![CDATA[
        this.keyset.removeAllKeys();
        this.keyset.destroy();
      ]]>
      </body>
    </method>

    <field name="hoststring">"shortcuts"</field>
    <field name="keyset">document.getAnonymousElementByAttribute(this, "sbid", "keyset");</field>
    <field name="keys">new Array();</field>

    <method name="shouldForceRebuild">
      <body>
        // If our internal objects are out of sync, rebuild.
        return (this.keys.length == 0);
      </body>
    </method>

    <method name="doRefreshCommands">
      <parameter name="stateonly"/>
      <body>
        <![CDATA[
        try
        {
          if (!stateonly) {
            this.removeCommands();
          }

          if ( this.commands )
          {
            for (var i in this.commands) {
              this.refreshCommandItems(this.commands[i], stateonly, null, this, null, 0, false);
            }
          }
        }
        catch( err )
        {
          alert( "sbCommands.xml - shortcuts - doRefreshCommands - " + err );
        }
        ]]>
      </body>
    </method>
    
    <method name="refreshCommandItems">
      <parameter name="cmdobject"/>
      <parameter name="stateonly"/>
      <parameter name="menu"/>
      <parameter name="parentnode"/>
      <parameter name="before"/>
      <parameter name="depth"/>
      <parameter name="radioitems"/>
      <body>
        <![CDATA[
          var key;
          try {
            // And make all the new stuff
            if (!cmdobject.getVisible(this.hoststring)) return;
            var num = cmdobject.getNumCommands(menu, this.hoststring);
            if (stateonly) num = this.keys.length;
            for ( var i = 0; i < num; i++ )
            {
              key = null;

              // skip ?
              if (!stateonly && !cmdobject.getCommandVisible( menu, i, this.hoststring )) continue;

              var subobject = cmdobject.getCommandSubObject( menu, i, this.hoststring );
              if (subobject) {
                this.refreshCommandItems(subobject, stateonly, menu, parentnode, before, depth, false);
                continue;
              }

              var obj_type;

              if (!stateonly)
              {
                // What type?
                if (radioitems) obj_type = "choiceitem";
                else obj_type = cmdobject.getCommandType( menu, i, this.hoststring );

                // What id?
                var obj_id = cmdobject.getCommandId( menu, i, this.hoststring );
                
                var makeKey;
                var skip;
                
                switch (obj_type) {  
                  case "submenu":
                  case "choice":
                    makeKey = false;
                    skip = false;
                    break;
                  case "separator":
                  case "custom":
                  case "value":
                    makeKey = false;
                    skip = true;
                    break;
                  case "action":
                  case "choiceitem":
                  case "flag":
                  default:
                    makeKey = true;
                    skip = false;
                    break;
                }
                
                if (skip) continue;
              
                if (makeKey) {
                  // Add a key
                  var modifiers;
                  var keyname;
                  
                  // No label unless you have a label
                  var modifiers = cmdobject.getCommandShortcutModifiers( menu, i, this.hoststring );
                  var keyname = cmdobject.getCommandShortcutKey( menu, i, this.hoststring );
                  var keycode = cmdobject.getCommandShortcutKeycode( menu, i, this.hoststring );
                  var local = cmdobject.getCommandShortcutLocal( menu, i, this.hoststring );
                  modifiers = this.translateEntity(modifiers);
                  keyname = this.translateEntity(keyname);
                  keycode = this.translateEntity(keycode);
                  
                  if ((!keyname || keyname == "") && 
                      (!keycode || keycode == "")) continue;
                  
                  var keytarget = this.parentNode;
                  if (this.playlist) keytarget = this.playlist.tree;
                  key = this.keyset.addKey( local, obj_id, modifiers, keyname, keycode, this, keytarget );

                  key.commandtype = obj_type;
                  key.commandmenu = menu;
                  key.commandindex = i;
                  key.commandobject = cmdobject;
                } else {
                  key = null;
                }
              }
              else
              {
                key = this.keys[i];
                obj_type = key.commandtype;
                cmdobject = key.commandobject;
              }

              if (key) {
                if ( cmdobject.getCommandEnabled( key.commandmenu, key.commandindex, this.hoststring ) ) {
                  key.setAttribute( "disabled", "false" );
                } else {
                  key.setAttribute( "disabled", "true" );
                }
              }
                
              if (!stateonly)
              {
                if (key) {
                  this.keys.push( key );
                }
                if (obj_type == "submenu" || obj_type == "choice") {
                  if (cmdobject.getCommandId(menu, i, this.hoststring) == null) {
                    alert("null submenu: menu = " + menu + ", index = " + i);
                  }
                  this.refreshCommandItems(cmdobject, stateonly, cmdobject.getCommandId(menu, i, this.hoststring), parentnode, null, depth+1, (obj_type == "choice"));
                }
              }
            }
          } catch (e) {
            var id="";
            if (key) {
              id = "- " + cmdobject.getCommandId(menu, key.commandindex, this.hoststring) + " ";
            }
            alert("sbCommands.xml - shortcuts - refreshCommandItems " + id + e);
          }
        ]]>
      </body>
    </method>

    <method name="doRemoveCommands">
      <body>
        <![CDATA[
          this.keyset.removeAllKeys();
          this.keys = new Array();
        ]]>
      </body>
    </method>

    <method name="onCommand">
      <parameter name="evt"/>
      <body>
        <![CDATA[
        try
        {
          if ( this.commands )
          {
            var cmdobject = evt.originalTarget.commandobject;
            if (!cmdobject) return;
            
            this.reportMetrics(evt.originalTarget.id);

            cmdobject.onCommand(evt.originalTarget.commandmenu, 
                                evt.originalTarget.commandindex, 
                                this.hoststring,
                                evt.originalTarget.id,
                                null);
          }
        }
        catch( err )
        {
          alert( "sbCommands.xml - shortcuts - onMenuCommand - " + err );
        }
      ]]>
      </body>
    </method>

    </implementation>

  </binding>


</bindings>


