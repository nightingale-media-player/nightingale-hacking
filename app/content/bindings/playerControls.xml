<?xml version="1.0"?>
<!-- vim: set sw=2 : -->
<!--
/*
 *=BEGIN SONGBIRD GPL
 *
 * This file is part of the Songbird web player.
 *
 * Copyright(c) 2005-2010 POTI, Inc.
 * http://www.songbirdnest.com
 *
 * This file may be licensed under the terms of of the
 * GNU General Public License Version 2 (the ``GPL'').
 *
 * Software distributed under the License is distributed
 * on an ``AS IS'' basis, WITHOUT WARRANTY OF ANY KIND, either
 * express or implied. See the GPL for the specific language
 * governing rights and limitations.
 *
 * You should have received a copy of the GPL along with this
 * program. If not, go to http://www.gnu.org/licenses/gpl.html
 * or write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 *=END SONGBIRD GPL
 */
-->

<!DOCTYPE bindings SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">




  <!-- VOLUME CONTROL -->




  <binding id="volume-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

    <handlers>
      <handler event="progressSliderChange" action="this.onTrackVolume();"/>
      <handler event="progressSliderRelease" action="this.onReleaseVolume();"/>
    </handlers>

  <implementation>

    <constructor>
        /* outside CDATA to get localized entity */
        this.setAttribute("tooltiptext", "&tooltip.control.volume;");
      <![CDATA[
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.className += " sb-player-volume-slider";

        // Then do the rest of your crap
        this.mm =
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // data remotes
        const on_remote_volume_change = {
          _that: this,
          observe: function volumeSlider_onChange( aSubject, aTopic, aData ) {
            this._that.onRemoteVolumeChange();
          }
        };
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_volume.bindObserver(on_remote_volume_change, true);

        this.remote_lastVolume = SB_NewDataRemote("faceplate.volume.last", null );

        const on_remote_mute = {
          _that: this,
          observe: function volumeSlider_onChange( aSubject, aTopic, aData ) {
            this._that.onRemoteMute(aData);
          }
        };
        this.remote_mute = SB_NewDataRemote( "faceplate.mute", null );
        this.remote_mute.bindObserver(on_remote_mute, true);

        this.sliderScale = 10000;
        this.maxpos = this.sliderScale;
        this.trackingVolume = false;

        // The slider value cannot be set correctly until the boxObject
        // dimensions are set. This waits until the window is loaded
        var self = this;
        window.addEventListener('load', function() {
            self.value = parseFloat(self.remote_volume.stringValue) * self.sliderScale;
            // initialize lastValue if it wasn't set
            if (self.remote_lastVolume.stringValue == "") {
                self.lastValue = self.value;
            }
        }, false);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.remote_volume) {
          this.remote_volume.unbind();
          this.remote_volume = null;
        }
        if (this.remote_lastVolume) {
          this.remote_lastVolume = null;
        }
        if (this.remote_mute) {
          this.remote_mute.unbind();
          this.remote_mute = null;
        }

        this.mm = null;
      ]]>
    </destructor>

    <!-- Override to make mute/unmute behaviour sane -->
    <method name="snapToMin">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.mm.volumeControl.mute = !this.mm.volumeControl.mute;
        ]]>
      </body>
    </method>

    <method name="onTrackVolume">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          // prevent this volume control from being updated while it is being
          // moved (but other volume controls are updated with our motion)
          this.trackingVolume = true;
          var scaledValue = this.value / this.sliderScale;
          this.mm.volumeControl.volume = scaledValue;

          this.remote_volume.stringValue = scaledValue;
          // set to mute when we're at zero
          this.mm.volumeControl.mute = (this.value == 0);
        ]]>
      </body>
    </method>

    <method name="onReleaseVolume">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.trackingVolume = false;
          this.mm.volumeControl.volume = this.value / this.sliderScale;
        ]]>
      </body>
    </method>

    <method name="onRemoteVolumeChange">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          try {
            this.value = parseFloat(this.remote_volume.stringValue) * this.sliderScale;
          } catch (err) {
            dump("playerControls.xml - onRemoteVolumeChange - " + err + "\n");
          }
        ]]>
      </body>
    </method>

    <method name="onRemoteMute">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          // the mute state changed
          if (this.remote_mute.boolValue) {
            if (this.value != 0) {
              this.lastValue = this.value;
            }
            this.mm.volumeControl.volume = 0;
          } else {
            var volume;
            if (this.value == 0) {
              volume = this.lastValue / this.sliderScale;
            } else {
              // This catches the case where the user exits mute by clicking on
              // the volume bar. The new value is not necessarily the same as
              // the last value prior to muting.
              volume = this.value / this.sliderScale;
              this.lastValue = this.value;
            }
            this.mm.volumeControl.volume = volume;
          }
        ]]>
      </body>
    </method>

    <!-- override the values in the progress slider to make it track the volume -->
    <property name="lastValue">
      <getter>
        return parseFloat(this.remote_lastVolume.stringValue) * this.sliderScale;
      </getter>
      <setter>
        this.remote_lastVolume.stringValue = val / this.sliderScale;
      </setter>
    </property>

   </implementation>

  </binding>




  <!-- MUTE CONTROL -->
  <!-- NOTE: This is no longer used anywhere in the application. All the current
       mute controls are in the volume-slider elements -->



  <binding id="mute-button">

    <content>
      <xul:hbox id="sb-player-mute-button" oncommand="onMute();" flex="1">
        <xul:button type="sb-clickhold"
                    hidden="false"
                    id="sb-player-mute-button-muteoff"
                    class="sb-player-mute-button-muteoff sb-player-button"
                    sbid="mute-off"
                    tooltiptext="&tooltip.control.mute;"
                    xbl:inherits="label,position">
          <xul:observes type="dataremote"
                    key="faceplate.mute"
                    attribute="hidden"
                    boolean="true"
                    inverted="false" />
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="sb-player-mute-menu-muteoff"
                          autocheck="false"
                          checked="false"
                          class="menuitem-iconic"
                          type="radio"
                          label="&tooltip.control.mute;"/>
          </xul:menupopup>
        </xul:button>
        <xul:button type="sb-clickhold"
                    hidden="false"
                    id="sb-player-mute-button-muteon"
                    class="sb-player-mute-button-muteon sb-player-button"
                    sbid="mute-on" tooltiptext="&tooltip.control.mute;"
                    xbl:inherits="label,position">
          <xul:observes type="dataremote"
                    key="faceplate.mute"
                    attribute="hidden"
                    boolean="true"
                    inverted="true" />
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="sb-player-mute-menu-muteon"
                          autocheck="false"
                          checked="true"
                          class="menuitem-iconic"
                          type="radio"
                          label="&tooltip.control.mute;"/>
          </xul:menupopup>
        </xul:button>
      </xul:hbox>
    </content>

    <implementation>

    <constructor>
      <![CDATA[
        this.mm =
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // Create and bind the data remotes
        this.remote_mute = SB_NewDataRemote( "faceplate.mute", null );

        // observer for DataRemote
        const on_remote_mute = {
          _that: this,
          observe: function dr_onMuteToggle( aSubject, aTopic, aData ) {
            this._that.onRemoteMute();
          }
        };
        this.remote_mute.bindObserver(on_remote_mute, true);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        // Release the data remotes
        if (this.remote_mute) {
          this.remote_mute.unbind();
          this.remote_mute = null;
        }
        this.mm = null;
      ]]>
    </destructor>

    <field name="mute_on">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-on');</field>
    <field name="mute_off">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-off');</field>

    <method name="onMute">
      <body>
        <![CDATA[
          // Yikes.  If we hide the clickholdbutton because of the popupmenu,
          // the popupmenu gets broken.  Therefore, we wait until the next UI
          // frame to change the mute state.
          var that = this;
          setTimeout( function() { that.doMute() }, 0 );
        ]]>
      </body>
    </method>

    <method name="doMute">
      <body>
        <![CDATA[
          if (this.getAttribute("disabled"))
            return;
          this.mm.volumeControl.mute = !this.mm.volumeControl.mute;
          // this will trigger onRemoteMute due to the data remote
        ]]>
      </body>
    </method>

    <method name="onRemoteMute">
      <body>
        <![CDATA[
          if (this.getAttribute("disabled"))
            return;
          var newmute = this.mm.volumeControl.mute;
          if (!newmute) {
            // restore last volume when coming back from mute state
            this.mm.volumeControl.volume =
              parseFloat(this.remote_lastVolume.stringValue);
          }
          else {
            if (parseFloat(this.remote_volume.stringValue) != 0) {
              this.remote_lastVolume.stringValue = this.remote_volume.stringValue;
            }
            this.mm.volumeControl.volume = 0;
          }
        ]]>
      </body>
    </method>

   </implementation>

  </binding>



  <!-- BASECLASS BINDINGS FOR SONGBIRD OVERLAY TRICKS

  These bindings will set some magic values inside of the objects we inherit from xpfe.

  It places the nodename as the id on the inner hbox for XBL Overlay and adds a class
  value that may be used in the CSS.

  -->
  <binding id="sb-button-base" extends="chrome://global/content/bindings/button.xml#button">
    <implementation>
      <constructor>
      <![CDATA[
        // ENFORCE CLICKABILITY!  (why do I have to do this?)
        this.setAttribute("mousethrough","never");

        // Get the nodename (without the namespace)
        var nameArray = this.nodeName.split(":");
        var nodeName = ( nameArray.length > 1 ) ? nameArray[ 1 ] : nameArray[ 0 ];

        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        var box = document.getAnonymousElementByAttribute(this, "class", "box-inherit button-box");
        box.setAttribute( 'id', nodeName );

        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " sb-player-button " + nodeName);
      ]]>
      </constructor>
    </implementation>
  </binding>

  <binding id="sb-checkbox-base" extends="chrome://global/content/bindings/checkbox.xml#checkbox-baseline">
    <implementation>
      <constructor>
      <![CDATA[
        // ENFORCE CLICKABILITY!  (why do I have to do this?)
        this.setAttribute("mousethrough","never");

        // Get the nodename (without the namespace)
        var nameArray = this.nodeName.split(":");
        var nodeName = ( nameArray.length > 1 ) ? nameArray[ 1 ] : nameArray[ 0 ];

        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        var box = document.getAnonymousElementByAttribute(this, "class", "checkbox-label-box");
        box.setAttribute( 'id', nodeName );

        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " " + nodeName);
      ]]>
      </constructor>
    </implementation>
  </binding>


  <!-- FORWARD BUTTON-->




  <binding id="forward-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">

  <handlers>
    <handler event="mousedown" button="0">
      <![CDATA[
        if (this.disabled)
          return;
        var sbIMediacoreStatus = Components.interfaces.sbIMediacoreStatus;
        this.seen_skip = false;
        if ( this.mm.status.state == sbIMediacoreStatus.STATUS_PLAYING) {
          this.skip = true;
          if ( ! this.skip_interval ) {
            this.skip_interval = setInterval( this.skipLoop, 1000, this );
          }
        }
      ]]>
    </handler>
    <handler event="mouseup" button="0">
      <![CDATA[
        this.skip = false;
      ]]>
    </handler>
    <handler event="command">
      <![CDATA[
        if ( !this.seen_skip ) {
          this.mm.sequencer.next();
        }
        this.skip = false;
      ]]>
    </handler>
    <handler event="mouseout">
      <![CDATA[
        if (this.disabled)
          return;
        if (this.skip_interval) {
          clearInterval( this.skip_interval );
          this.skip_interval = null;
        }
      ]]>
    </handler>
    <handler event="mouseover">
      <![CDATA[
        if (this.disabled)
          return;
        if (this.skip && !this.skip_interval ) {
          this.skip_interval = setInterval( this.skipLoop, 1000, this );
        }
      ]]>
    </handler>
  </handlers>

  <implementation>
    <field name="seen_skip">false</field>
    <field name="skip">false</field>
    <field name="skip_interval">null</field>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.fwd;")
      <![CDATA[
        this.mm =
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        this.remote_next_disabled =
          SBDataBindElementProperty("playlist.next.disabled",
                                    this,
                                    "disabled",
                                    true );
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        if(this.remote_next_disabled) {
          this.remote_next_disabled.unbind();
          this.remote_next_disabled = null;
        }

        this.mm = null;
      ]]>
    </destructor>

    <method name="skipLoop">
      <parameter name="_this"/>
      <body>
        <![CDATA[
          if ( _this.skip ) {
            // If we're allowed to skip
            if ( _this.mm.playbackControl.duration > 0 ) {
              _this.seen_skip = true;
              var target = _this.mm.playbackControl.position + 15000;
              var max = _this.mm.playbackControl.duration - 1000;
              _this.mm.playbackControl.position = ( max < target ) ? max : target;
            }
          }
          else {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>

  </binding>




  <!-- BACK BUTTON-->




  <binding id="back-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">

  <handlers>
    <handler event="mousedown" button="0">
      <![CDATA[
        if (this.disabled)
          return;
        var sbIMediacoreStatus = Components.interfaces.sbIMediacoreStatus;
        this.seen_skip = false;
        if ( this.mm.status.state == sbIMediacoreStatus.STATUS_PLAYING) {
          this.skip = true;
          if ( ! this.skip_interval ) {
            this.skip_interval = setInterval( this.skipLoop, 1000, this );
          }
        }
      ]]>
    </handler>
    <handler event="mouseup" button="0">
      <![CDATA[
        this.skip = false;
      ]]>
    </handler>
    <handler event="command">
      <![CDATA[
        if ( !this.seen_skip ) {
          this.mm.sequencer.previous();
        }
        this.skip = false;
      ]]>
    </handler>
    <handler event="mouseout">
      <![CDATA[
        if (this.disabled)
          return;
        if (this.skip_interval) {
          clearInterval( this.skip_interval );
          this.skip_interval = null;
        }
      ]]>
    </handler>
    <handler event="mouseover">
      <![CDATA[
        if (this.disabled)
          return;
        if (this.skip && !this.skip_interval ) {
          this.skip_interval = setInterval( this.skipLoop, 1000, this );
        }
      ]]>
    </handler>
  </handlers>

  <implementation>
    <field name="seen_skip">false</field>
    <field name="skip">false</field>
    <field name="skip_interval">null</field>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.back;")
      <![CDATA[
        this.mm =
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        this.remote_previous_disabled =
          SBDataBindElementProperty("playlist.previous.disabled",
                                    this,
                                    "disabled",
                                    true);
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        if(this.remote_previous_disabled) {
          this.remote_previous_disabled.unbind();
          this.remote_previous_disabled = null;
        }

        this.mm = null;
      ]]>
    </destructor>

    <method name="skipLoop">
      <parameter name="_this"/>
      <body>
        <![CDATA[
          if ( _this.skip ) {
            // If we're allowed to skip
            if ( _this.mm.playbackControl.duration > 0 ) {
              _this.seen_skip = true;
              var target = _this.mm.playbackControl.position - 15000;
              _this.mm.playbackControl.position = ( target > 1 ) ? target : 1;
            }
          }
          else {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>

  </binding>




  <!-- REPEAT CONTROL -->




  <binding id="repeat-button">

   <content>
     <xul:stack id="sb-player-repeat-button" xbl:inherits="class=class" >
       <xul:button id="repeat_none"
                   class="sb-player-repeat-button-repnone sb-player-button"
                   oncommand="onRepeat(event.target);"
                   tooltiptext="&menu.control.repx;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.repeat"
                   attribute="hidden"
                   onchange="return parseInt( value ) != 0" />
       </xul:button>
       <xul:button id="repeat_1"
                   class="sb-player-repeat-button-rep1 sb-player-button"
                   oncommand="onRepeat(event.target);"
                   tooltiptext="&menu.control.rep1;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.repeat"
                   attribute="hidden"
                   onchange="return parseInt( value ) != 1" />
       </xul:button>
       <xul:button id="repeat_all"
                   class="sb-player-repeat-button-repall sb-player-button"
                   oncommand="onRepeat(event.target);"
                   tooltiptext="&menu.control.repa;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.repeat"
                   attribute="hidden"
                   onchange="return parseInt( value ) != 2" />
       </xul:button>
     </xul:stack>
   </content>

  <implementation>
    <property name="disabled"
              onset="if (val) this.setAttribute('disabled', 'true');
                     else this.removeAttribute('disabled');
                     return val;"
              onget="return this.hasAttribute('disabled');" />

    <constructor>
      <![CDATA[
        this.mm =
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // Create and bind data remotes
        this.remote_repeat_disabled = 
          SBDataBindElementProperty("playlist.repeat.disabled",
                                    this,
                                    "disabled",
                                    true );

        this.remote_repeat = SB_NewDataRemote( "playlist.repeat", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "repeat binding destructor");
        if (this.remote_repeat) {
          this.remote_repeat.unbind();
          this.remote_repeat = null;
        }

        if(this.remote_repeat_disabled) {
          this.remote_repeat_disabled.unbind();
          this.remote_repeat_disabled = null;
        }

        if(this.mm) {
          this.mm = null;
        }
      ]]>
    </destructor>

    <field name="repeat_none">document.getAnonymousElementByAttribute(this, 'id', 'repeat_none');</field>
    <field name="repeat_1">document.getAnonymousElementByAttribute(this, 'id', 'repeat_1');</field>
    <field name="repeat_all">document.getAnonymousElementByAttribute(this, 'id', 'repeat_all');</field>

    <method name="onRepeat">
      <parameter name="target"/>
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          var value = 0;
          switch( target.id )
          {
            case "menu_repeat_none":
              value = 0;
              break;
            case "menu_repeat_1":
              value = 1;
              break;
            case "menu_repeat_all":
              value = 2;
              break;
            default:
              switch ( this.remote_repeat.intValue )
              {
                case (0): // Apparently, "case 0:" != "case (0):" ?!?!?
                  value = 2;
                  break;
                case (1): // BUT, "case 1:" == "case (1):" ?!?!?
                  value = 0;
                  break;
                case (2):
                  value = 1;
                  break;
              }
              break;
          }

          this.mm.sequencer.repeatMode = value;
        ]]>
      </body>
    </method>

   </implementation>

  </binding>




  <!-- SHUFFLE CONTROL -->




  <binding id="shuffle-button">

   <content>
     <xul:stack id="sb-player-shuffle-button" xbl:inherits="class=class" oncommand="onShuffle( );">
       <xul:button id="sb-player-shuffle-button-off"
                   sbid="shuffle_off"
                   class="sb-player-shuffle-button-off sb-player-button"
                   tooltiptext="&tooltip.control.shuf_off;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.shuffle"
                   attribute="hidden"
                   onchange="return parseInt( value ) != 0" />
       </xul:button>
       <xul:button id="sb-player-shuffle-button-on"
                   sbid="shuffle_on"
                   class="sb-player-shuffle-button-on sb-player-button"
                   tooltiptext="&tooltip.control.shuffle;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.shuffle"
                   attribute="hidden"
                   onchange="return parseInt( value ) != 1" />
       </xul:button>
     </xul:stack>
   </content>

  <implementation>
    <property name="disabled"
              onset="if (val) this.setAttribute('disabled', 'true');
                     else this.removeAttribute('disabled');
                     return val;"
              onget="return this.hasAttribute('disabled');" />

    <constructor>
      <![CDATA[
        this.mm =
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // Create and bind data remotes
        this.remote_shuffle_disabled = 
          SBDataBindElementProperty("playlist.shuffle.disabled",
                                    this,
                                    "disabled",
                                    true );

        this.remote_shuffle = SB_NewDataRemote( "playlist.shuffle", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "shuffle binding destructor");
        if(this.remote_shuffle) {
          this.remote_shuffle.unbind();
          this.remote_shuffle = null;
        }

        if(this.remote_shuffle_disabled) {
          this.remote_shuffle_disabled.unbind();
          this.remote_shuffle_disabled = null;
        }

        if(this.mm) {
          this.mm = null;
        }
      ]]>
    </destructor>

    <field name="shuffle_off">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_off');</field>
    <field name="shuffle_on">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_on');</field>

    <method name="onShuffle">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.mm.sequencer.mode =
            !this.remote_shuffle.boolValue ?
            this.mm.sequencer.MODE_SHUFFLE :
            this.mm.sequencer.MODE_FORWARD;
        ]]>
      </body>
    </method>

   </implementation>

  </binding>




  <!-- SEEK CONTROL -->




  <binding id="seek-slider">
   <!-- forked from progressSlider.xml by stevel -->
   <handlers>
     <handler event="progressSliderChange" action="this.onTrackSeekbar();"/>
     <handler event="progressSliderRelease" action="this.onReleaseSeekbar();"/>
   </handlers>

   <content>
     <xul:box sbid="sb-progress-slider" xbl:inherits="orient,class" flex="1">
       <xul:stack xbl:inherits="class" flex="1">
         <xul:progressmeter sbid="sb-progress-slider-progress"
                            class="sb-progress-slider"
                            xbl:inherits="orient,class,dir"
                            flex="1"/>
         <xul:slider sbid="sb-progress-slider-slider" class="sb-progress-slider"
                     xbl:inherits="disabled,orient,maxpos,class,dir"
                     pageincrement="0" flex="1"
                     onmousedown="slidermousedown(event)"
                     onmouseup="slidermouseup(event)"
                     onmousemove="slidermousemove(event)" mousethrough="never">
           <xul:thumb sbid="sb-progress-slider-thumb" class="sb-progress-slider"
                      xbl:inherits="class"/>
         </xul:slider>
       </xul:stack>
       <children/>

    </xul:box>
  </content>

  <implementation>

    <constructor>
    <![CDATA[
      this.progress.max = this._SCALE_MAX;

      // OVERLAY TARGET ID MATCHES ELEMENT NAME
      this.box.setAttribute("id", "sb-player-seek-slider" );

      // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
      this.setAttribute("class", this.getAttribute("class") + " sb-player-seek-slider");

      this.mm =
        Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                  .getService(Components.interfaces.sbIMediacoreManager);

      // observer for DataRemote
      const on_remote_position_change = {
        _that: null,
        observe: function( aSubject, aTopic, aData ) { this._that.onRemotePositionChange(); }
      };
      on_remote_position_change._that = this;

      // Create and bind data remotes
      this.remote_position = SB_NewDataRemote( "metadata.position", null );
      this.remote_position.bindObserver(on_remote_position_change, true);
      this.remote_length = SBDataBindElementAttribute( "metadata.length", this, "maxpos" );

      this.trackingPosition = 0;
      this.scrubbingPosition = false;
      this.seekInProgress = false;
      this.wasPlayingBeforeSeek = false;

      this.eventListener = {
        that: this,
        onMediacoreEvent: function(aEvent) {
          if (aEvent.type == aEvent.STREAM_PAUSE) {
            // If our seek finished, issue another seek to wherever we're now
            // pointing to.  TODO: Skip this if we'd be seeking to the same
            // point.
            if (this.that.scrubbingPosition) {
              this.that.doScrubbingSeek();
            }
          }
        }
      }

      this.mm.addListener(this.eventListener);
    ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "seek-slider binding destructor");
        if (this.remote_position) {
          this.remote_position.unbind();
          this.remote_position = null;
        }
        if (this.remote_length) {
          this.remote_length.unbind();
          this.remote_length = null;
        }

        this.mm.removeListener(this.eventListener);
        this.mm = null;
      ]]>
    </destructor>

    <field name="_tracking">this._TRACKING_NONE</field>
    <field name="box">document.getAnonymousElementByAttribute(this, 'sbid', 'sb-progress-slider');</field>
    <field name="slider">document.getAnonymousElementByAttribute(this, 'sbid', 'sb-progress-slider-slider');</field>
    <field name="thumb">document.getAnonymousElementByAttribute(this, 'sbid', 'sb-progress-slider-thumb');</field>
    <field name="progress">document.getAnonymousElementByAttribute(this, 'sbid', 'sb-progress-slider-progress');</field>
    <field name="lastValue">this.value</field>
    <field name="_SCALE_MAX" readonly="true">10000</field>
    <field name="_TRACKING_NONE" readonly="true">0</field>
    <field name="_TRACKING_SLIDER" readonly="true">1</field>
    <field name="_TRACKING_THUMB" readonly="true">2</field>

    <property name="value">
      <getter>
        return this.slider.getAttribute('curpos');
      </getter>
      <setter>
        var offset = this.thumb.boxObject.width /
                     this.slider.boxObject.width * this.maxpos;
        this.progress_value = val - (offset / 2);
        return this.slider.setAttribute('curpos', val);
      </setter>
    </property>

    <property name="progress_value">
      <getter>
      <![CDATA[
        var pos = this.progress.getAttribute('value');
        if (pos < 0) {
          // We sometimes get negative values here, which don't make any sense.
          return 0;
        }
        else {
          return ( pos * this.maxpos ) / this._SCALE_MAX;
        }
      ]]>
      </getter>
      <setter>
      <![CDATA[
        var prog = (val * this._SCALE_MAX) / this.maxpos;
        this.progress.setAttribute('value', prog);
      ]]>
      </setter>
    </property>

    <property name="maxpos">
      <getter>
        return this.slider.getAttribute('maxpos');
      </getter>
      <setter>
        this.slider.setAttribute('maxpos', val);
        this.progress_value = this.value;
        // hide the slider if the length of track is zero (stream)
        if (val == 0) {
          this.slider.setAttribute('hidden', true);
        }
        else {
          this.slider.setAttribute('hidden', false);
        }
        return this.maxpos;
      </setter>
    </property>

    <property name="data_tracking" readonly="true">
      <getter>
        return this.getAttribute('data_tracking');
      </getter>
    </property>

    <property name="is_tracking_data">
      <getter>
        var data_str = this.getAttribute('data_tracking');
        if ( data_str.length ) {
          return SBDataGetBoolValue( data_str );
        }
        return "";
      </getter>
      <setter>
        var data_str = this.getAttribute('data_tracking');
        if ( data_str.length ) {
          return SBDataSetBoolValue( data_str, val );
        }
        return "";
      </setter>
    </property>

    <method name="sendChangeEvent">
      <body>
        var e = document.createEvent("Events");
        e.initEvent("progressSliderChange", false, true);
        this.dispatchEvent(e);
      </body>
    </method>

    <method name="sendReleaseEvent">
      <body>
        var e = document.createEvent("Events");
        e.initEvent("progressSliderRelease", false, true);
        this.dispatchEvent(e);
      </body>
    </method>

    <method name="mouseonthumb">
      <parameter name="x"/>
      <parameter name="y"/>
      <body>
        <![CDATA[
          if (x >= this.thumb.boxObject.x && x <= this.thumb.boxObject.x + this.thumb.boxObject.width &&
              y >= this.thumb.boxObject.y && y <= this.thumb.boxObject.y + this.thumb.boxObject.height) {
            return true;
          }
          return false;
        ]]>
      </body>
    </method>

    <method name="slidermousedown">
      <parameter name="event"/>
      <body>
        <![CDATA[
          if (event.button == this._TRACKING_NONE ) {
            if (this.mouseonthumb(event.screenX, event.screenY)) {
              this._tracking = this._TRACKING_THUMB;
            }
            else {
              this._tracking = this._TRACKING_SLIDER;
              this.handlemouse(event);
            }
            if ( this._tracking != this._TRACKING_NONE ) {
              // Report if requested
              this.is_tracking_data = true;
            }
            this.sendChangeEvent();
          }
        ]]>
      </body>
    </method>

    <method name="slidermouseup">
      <parameter name="event"/>
      <body>
        <![CDATA[
          if (this._tracking == this._TRACKING_NONE)
            return;

          this._tracking = this._TRACKING_NONE;
          this.is_tracking_data = false;
          this.sendReleaseEvent();
          if (this.value != 0 && this.value != this.maxpos)
            this.lastValue = this.value;
        ]]>
      </body>
    </method>

    <method name="slidermousemove">
      <parameter name="event"/>
      <body>
          if (this._tracking == this._TRACKING_THUMB) {
            this.progress_value = this.value;
          } else if (this._tracking == this._TRACKING_NONE) {
            return;
          } else {
            this.handlemouse(event);
          }
          this.sendChangeEvent();
      </body>
    </method>

    <method name="handlemouse">
      <parameter name="event"/>
      <body>
        <![CDATA[
          var m = this.maxpos;
          var x = event.screenX - this.slider.boxObject.screenX;
          var y = event.screenY - this.slider.boxObject.screenY;

          var v = 0;
          v = (x - this.thumb.boxObject.width/2) /
              (this.slider.boxObject.width - this.thumb.boxObject.width) * m;
          if (v < 0) v = 0; else if (v > m) v = m;
          if (this.getAttribute("dir") == "reverse") v = m - v;
          this.slider.setAttribute('curpos', ''+v);

          var offset = this.thumb.boxObject.width /
                       this.slider.boxObject.width * this.maxpos;
          //this.progress_value = v;
          this.progress_value = v - (offset / 2);
        ]]>
      </body>
    </method>

    <method name="snapToValue">
      <parameter name="val"/>
      <body>
        <![CDATA[
          if (val == this.value) {
            val = this.lastValue;
          }
          this.value = val;

          // send the event to any listeners
          this.is_tracking_data = true;
          this.sendChangeEvent();
          this.is_tracking_data = false;
          this.sendReleaseEvent();
        ]]>
      </body>
    </method>
    <method name="snapToMax">
      <body>
        return this.snapToValue(this.maxpos);
      </body>
    </method>

    <method name="onTrackSeekbar">
      <body>
        <![CDATA[
          if (!this.trackingPosition) {
            this.trackingPosition = 1;

            // We do scrubbing for video only.
            if (this.mm.playbackControl.isPlayingVideo) {
              this.scrubbingPosition = true;
              if (this.mm.status.state ==
                  Components.interfaces.sbIMediacoreStatus.STATUS_PLAYING) {
                this.wasPlayingBeforeSeek = true;
              }
              else {
                this.wasPlayingBeforeSeek = false;
              }
              this.mm.playbackControl.pause();
            }
          }

          // Seek while tracking if we're scrubbing. Don't start a seek
          // unless the previous one completed, otherwise we never make
          // any progress...
          if (this.scrubbingPosition && !this.seekInProgress) {
            this.doScrubbingSeek();
          }
        ]]>
      </body>
    </method>

    <method name="onReleaseSeekbar">
      <body>
        <![CDATA[
        try {
          // Setting the position may fail if the format doesn't support
          // seeking or if http resuming does not work.
          this.seekInProgress = false;
          this.mm.playbackControl.position = this.value;

          if (this.scrubbingPosition) {
            this.scrubbingPosition = false;
            if (this.wasPlayingBeforeSeek) {
              this.mm.playbackControl.play();
            }
          }
        }
        catch(e) {
          Components.utils.reportError(e);
        }
        this.trackingPosition = 0;
        ]]>
      </body>
    </method>

    <method name="onRemotePositionChange">
      <body>
        <![CDATA[
          // if we are the control changing the position, ignore this callback
          if (this.trackingPosition)
            return;

          this.value = this.remote_position.intValue;
        ]]>
      </body>
    </method>

    <method name="doScrubbingSeek">
      <body>
        try {
          // Scrubbing seeks only show keyframes for mediacores that support
          // that.
          this.mm.playbackControl.seek(this.progress_value, Components.interfaces.sbIMediacorePlaybackControl.SEEK_FLAG_KEYFRAME);
          this.seekInProgress = true;
        } catch(e) {
          // Seeking failed; disable scrubbing.
          this.scrubbingPosition = false;
          if (this.wasPlayingBeforeSeek)
            this.mm.playbackControl.play();
        }
      </body>
    </method>

   </implementation>

  </binding>





  <!-- PLAYPAUSE/PLAY/PAUSE/STOP CONTROLS -->


  <binding id="play-control-base">

    <implementation>

      <constructor>
        <![CDATA[
        if (typeof(ColumnSpecParser) == "undefined") {
          Components.utils.import("resource://app/jsmodules/sbColumnSpecParser.jsm");
          if (!ColumnSpecParser)
            throw new Error("Import of sbColumnSpecParser module failed");
        }
        this.mm =
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);
        ]]>
      </constructor>
      <destructor>
        <![CDATA[
          this.mm = null;
        ]]>
      </destructor>

      <method name="playbackPlay">
        <parameter name="nopause"/>
        <body>
          <![CDATA[
            // If we are already playing something just pause/unpause playback
            var status = this.mm.status;
            var sbIMediacoreStatus = Components.interfaces.sbIMediacoreStatus;
            if (status.state == sbIMediacoreStatus.STATUS_PAUSED || nopause) {
              this.mm.playbackControl.play();
            } else if(status.state == sbIMediacoreStatus.STATUS_PLAYING ||
                      status.state == sbIMediacoreStatus.STATUS_BUFFERING) {
              this.mm.playbackControl.pause();

            // Otherwise dispatch a play event.  Someone should catch this
            // and intelligently initiate playback.  If not, just have
            // the playback service play the default.
            } else {
              var event = document.createEvent("Events");
              event.initEvent("Play", true, true);
              var notHandled = this.dispatchEvent(event);
              if (notHandled) {
                // If we have no context, initiate playback
                // via the root application controller
                var app = Components.classes["@songbirdnest.com/Songbird/ApplicationController;1"]
                                    .getService(Components.interfaces.sbIApplicationController);
                app.playDefault();
              }
            }
          ]]>
        </body>
      </method>

      <method name="playbackPause">
        <body>
          <![CDATA[
            this.mm.playbackControl.pause();
          ]]>
        </body>
      </method>

      <method name="playbackStop">
        <body>
          <![CDATA[
            this.mm.sequencer.stop();
          ]]>
        </body>
      </method>

    </implementation>
  </binding>


  <!-- a play button, always enabled because it is legitimate to restart playback in the middle of playback -->

  <binding id="play-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">

    <content>
      <xul:hbox id="sb-player-play-button" flex="1" xbl:inherits="hidden,class">

        <xul:button type="sb-clickhold"
                    id="sb-player-play-button-play"
                    sbid="play"
                    class="sb-player-play-button-play sb-player-button"
                    oncommand="onPlay();"
                    tooltiptext="&tooltip.control.play;"
                    xbl:inherits="label,position">
          <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
        </xul:button>

      </xul:hbox>
    </content>

  <implementation>

    <method name="onPlay">
      <body>
        this.playbackPlay(true);
      </body>
    </method>

   </implementation>

  </binding>


  <!-- a pause/restore button -->

  <binding id="pause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">

    <content>
      <xul:hbox id="sb-player-pause-button" flex="1" xbl:inherits="hidden,class">
        <xul:stack xbl:inherits="class=class" >

          <xul:button type="sb-clickhold"
                      id="sb-player-pause-button-pause"
                      sbid="pause"
                      class="sb-player-pause-button-pause sb-player-button"
                      onmousedown="onPause();"
                      tooltiptext="&tooltip.control.pause;"
                      xbl:inherits="label,position">

            <xul:observes type="dataremote"
                      key="faceplate.playing"
                      attribute="disabled"
                      boolean="true"
                      inverted="true"/>
            <xul:observes type="dataremote"
                      key="faceplate.paused"
                      attribute="hidden"
                      boolean="true"
                      inverted="false"/>

            <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
          </xul:button>

          <xul:button type="sb-clickhold"
                      id="sb-player-pause-button-resume"
                      sbid="resume"
                      class="sb-player-pause-button-resume sb-player-button"
                      oncommand="onPlay();"
                      tooltiptext="&tooltip.control.resume;"
                      xbl:inherits="label,position">

            <xul:observes type="dataremote"
                      key="faceplate.playing"
                      attribute="disabled"
                      boolean="true"
                      inverted="true"/>
            <xul:observes type="dataremote"
                      key="faceplate.paused"
                      attribute="hidden"
                      boolean="true"
                      inverted="true"/>
            <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
          </xul:button>

        </xul:stack>
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>
    <field name="resume">document.getAnonymousElementByAttribute(this, 'sbid', 'resume');</field>

    <method name="onPause">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackPause();
        ]]>
      </body>
    </method>

    <method name="onPlay">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackPlay();
        ]]>
      </body>
    </method>

   </implementation>

  </binding>

  <!-- a stop button that enables itself when the core is playing, and disables itself when the core is stopped -->

  <binding id="stop-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">

    <content>
      <xul:hbox id="sb-player-stop-button" flex="1" xbl:inherits="hidden,class">

        <xul:button type="sb-clickhold"
                id="sb-player-stop-button-stop"
                sbid="stop"
                class="sb-player-stop-button-stop sb-player-button"
                oncommand="onStop();"
                tooltiptext="&tooltip.control.stop;"
                xbl:inherits="label,position">

          <xul:observes type="dataremote"
                            key="faceplate.playing"
                            attribute="disabled"
                            boolean="true"
                            inverted="true" />
         <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
        </xul:button>

      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="stop">document.getAnonymousElementByAttribute(this, 'sbid', 'stop');</field>

    <method name="onStop">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackStop();
        ]]>
      </body>
    </method>

   </implementation>

  </binding>



  <binding id="playpause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">

    <content>
      <xul:hbox id="sb-player-playpause-button" flex="1" xbl:inherits="hidden,class,disabled">

        <xul:button type="sb-clickhold"
                    id="sb-player-playpause-button-play"
                    sbid="play"
                    class="sb-player-playpause-button-play sb-player-button"
                    oncommand="onPlayPause(event.target);"
                    delayDuration="2000"
                    tooltiptext="&tooltip.control.play;"
                    xbl:inherits="label,position,disabled"
                    onmenushowing="syncMenus();">
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
            <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
            <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
          </xul:menupopup>
        </xul:button>

        <xul:button type="sb-clickhold"
                    id="sb-player-playpause-button-pause"
                    sbid="pause"
                    class="sb-player-playpause-button-pause sb-player-button"
                    oncommand="onPlayPause(event.target);"
                    delayDuration="2000"
                    tooltiptext="&tooltip.control.pause;"
                    xbl:inherits="label,position,disabled"
                    onmenushowing="syncMenus();">
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
              <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
              <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
              <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
            </xul:menupopup>
        </xul:button>
        
        <xul:button type="sb-clickhold"
                id="sb-player-stop-button-stop"
                sbid="stop"
                class="sb-player-stop-button-stop sb-player-button"
                oncommand="onPlayPause(event.target);"
                delayDuration="2000"
                tooltiptext="&tooltip.control.stop;"
                xbl:inherits="label,position,disabled"
                onmenushowing="syncMenus();">
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
              <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
              <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
              <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
            </xul:menupopup>
        </xul:button>

      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
        // observer for DataRemote
        this.on_state_change = {
          _that: null,
          observe: function( aSubject, aTopic, aData ) { this._that.onStateChanged(); }
        };
        this.on_state_change._that = this;
        this.remote_playing = SB_NewDataRemote("faceplate.playing", null);
        this.remote_paused = SB_NewDataRemote("faceplate.paused", null);
        this.remote_length = SB_NewDataRemote( "metadata.length", null );
        this.remote_url = SB_NewDataRemote( "faceplate.play.url", null );
        this.remote_playing.bindObserver(this.on_state_change, false);
        this.remote_paused.bindObserver(this.on_state_change, false);
        this.remote_length.bindObserver(this.on_state_change, false);
        this.remote_url.bindObserver(this.on_state_change, false);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        this.remote_playing.unbind();
        this.remote_paused.unbind();
        this.remote_length.unbind();
        this.remote_url.unbind();
      ]]>
    </destructor>

    <field name="play">document.getAnonymousElementByAttribute(this, 'sbid', 'play');</field>
    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>
    <field name="stop">document.getAnonymousElementByAttribute(this, 'sbid', 'stop');</field>

    <method name="onStateChanged">
      <body>
        <![CDATA[
          /*
            While buffering files have always the length zero.
            Since you may want to stop the buffering of external files, its logic to display the stop buttons. Streams also have the length zero.
            Pausing buffering is strange.
          */
          if (this.remote_playing.boolValue && !this.remote_paused.boolValue && (this.remote_length.intValue > 0 || this.remote_url.stringValue.match(/^file:/) ) ) {
            this.play.hidden = true;
            this.stop.hidden = true;
            this.pause.hidden = false;
          }	else if (this.remote_playing.boolValue && this.remote_length.intValue == 0) {
            this.play.hidden = true;
            this.stop.hidden = false;
            this.pause.hidden = true;
          } else {
            this.play.hidden = false;
            this.stop.hidden = true;
            this.pause.hidden = true;
          }
        ]]>
      </body>
    </method>

    <method name="syncMenus">
      <body>
        this.syncMenu(this.play);
        this.syncMenu(this.pause);
        this.syncMenu(this.stop);
      </body>
    </method>

    <method name="syncMenu">
      <parameter name="parent"/>
      <body>
        <![CDATA[
          var sbIMediacoreStatus = Components.interfaces.sbIMediacoreStatus;
          var status = this.mm.status;
          for (var i=0;i<parent.childNodes.length;i++) {
            var node = parent.childNodes[i];
            switch (node.id) {
              case "menu_play":
                // play is disabled if we are already playing but we are not also paused (playing remains true while we are paused!)
                node.disabled = (status.state == sbIMediacoreStatus.STATUS_PLAYING);
                break;
              case "menu_pause":
                // pause is disabled if we are already paused, or if we are stopped
                node.disabled = (status.state == sbIMediacoreStatus.STATUS_PAUSED ||
                                 status.state != sbIMediacoreStatus.STATUS_PLAYING);
                break;
              case "menu_stop":
                // stop is disabled if we are already stopped (ie, the playbutton is visible, but we are not paused)
                node.disabled = (status.state == sbIMediacoreStatus.STATUS_STOPPED);
                break;
            }
          }
        ]]>
      </body>
    </method>

    <method name="onPlay">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackPlay();
        ]]>
      </body>
    </method>

    <method name="onPause">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackPause();
        ]]>
      </body>
    </method>

    <method name="onStop">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackStop();
        ]]>
      </body>
    </method>

    <method name="onPlayPause">
      <parameter name="target"/>
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          var sbid = target.getAttribute("sbid");
          if (sbid == "play") this.onPlay();
          else if (sbid == "pause") this.onPause();
          else if (sbid == "stop") this.onStop();
          else {
            switch (target.id) {
              case "menu_play": this.onPlay(); break;
              case "menu_pause": this.onPause(); break;
              case "menu_stop": this.onStop(); break;
            }
          }
        ]]>
      </body>
    </method>

   </implementation>

  </binding>



  <!-- CONTROL PANE BUTTONS BLOCK -->

  <binding id="control-buttons">

    <content>
      <xul:hbox id="sb-player-control-buttons" flex="1" xbl:inherits="class,hidden">
        <xul:sb-player-back-button id="sb-player-control-buttons-back" class="sb-player-button" xbl:inherits="class"/>
        <!-- Bonus Buttons!
          <xul:sb-player-pause-button id="sb-player-control-buttons-pause" popupanchor="topleft" popupalign="bottomleft"/>
          <xul:sb-player-play-button id="sb-player-control-buttons-play" popupanchor="topleft" popupalign="bottomleft"/>
          <xul:sb-player-stop-button id="sb-player-control-buttons-stop" popupanchor="topleft" popupalign="bottomleft"/>
        -->
        <xul:sb-player-playpause-button id="sb-player-control-buttons-playpause" class="sb-player-button" xbl:inherits="class" popupanchor="topleft" popupalign="bottomleft"/>
        <xul:sb-player-forward-button id="sb-player-control-buttons-forward" class="sb-player-button" xbl:inherits="class"/>
      </xul:hbox>
    </content>

    <implementation>
      <constructor>
      </constructor>
    </implementation>

  </binding>



  <!-- TOTALTIME DISPLAY -->

  <binding id="totaltime-label">

    <content>
      <xul:hbox id="sb-player-totaltime-label" flex="1" xbl:inherits="class,align,crop,disabled,flex">
        <xul:label sbid="timelabel" xbl:inherits="class,align,crop,disabled,flex" mousethrough="never">
          <xul:observes type="dataremote"
                        key="metadata.length.str"
                        attribute="value"/>
        </xul:label>
      </xul:hbox>
    </content>

    <handlers>
      <handler event="mousedown" action="this.onTotalDown();"/>
    </handlers>


  <implementation>

    <constructor>
      <![CDATA[
        this.mm =
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // Create and bind data remote
        this.remote_showRemaining = SB_NewDataRemote( "faceplate.showremainingtime", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "totaltime binding destructor");
        this.remote_showRemaining = null;

        this.mm = null;
      ]]>
    </destructor>

    <method name="onTotalDown">
      <body>
        <![CDATA[
          var len = this.mm.playbackControl.duration;
          if ( len > 0 )
            this.remote_showRemaining.boolValue = !this.remote_showRemaining.boolValue;
          // If you try to toggle it while it is zero, you lose the state.
          else
            this.remote_showRemaining.boolValue = false;
        ]]>
      </body>
    </method>

   </implementation>

  </binding>



  <!-- ARTIST DISPLAY -->


  <binding id="artist-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">

    <implementation>

      <constructor>
        this.data  = "metadata.artist";
      </constructor>

    </implementation>

  </binding>



  <!-- TITLE DISPLAY -->


  <binding id="title-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">

  <implementation>

    <constructor>
      <![CDATA[
        this.data  = "metadata.title";
        this.autotip = this.getAttribute("autotip");
        if (this.autotip) {
          // observer for DataRemote
          this.on_remote_artist_album_change = {
            _that: null,
            observe: function( aSubject, aTopic, aData ) {
              try {
                this._that.rebuildTip();
              }
              catch(e) {}
            }
          };
          this.on_remote_artist_album_change._that = this;

          // Create and bind data remotes
          this.remote_artist = SB_NewDataRemote( "metadata.artist", null );
          this.remote_album = SB_NewDataRemote( "metadata.album", null );
          this.remote_artist.bindObserver(this.on_remote_artist_album_change, true);
          this.remote_album.bindObserver(this.on_remote_artist_album_change, true);

          this.rebuildTip();
        }
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        this.on_remote_artist_album_change = null;
        if (this.remote_album) {
          this.remote_album.unbind();
          this.remote_album = null;
        }
        if (this.remote_artist) {
          this.remote_artist.unbind();
          this.remote_artist = null
        }
      ]]>
    </destructor>

    <method name="rebuildTip">
      <body>
        <![CDATA[
          try {
            var tip = "";
            if ( this.remote_artist.stringValue &&
                 this.remote_artist.stringValue.length ) {
              tip = this.remote_artist.stringValue;
            }
            if ( this.remote_album.stringValue &&
                 this.remote_album.stringValue.length ) {
              if (tip.length > 0) tip += " / ";
              tip += this.remote_album.stringValue;
            }
            this.label.setAttribute("tooltiptext", tip);
          } catch (e) {
            alert("playerControls.xml - rebuildTip - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>

  </binding>



  <!-- ALBUM DISPLAY -->


  <binding id="album-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">

  <implementation>

    <constructor>
      this.data  = "metadata.album";
    </constructor>

   </implementation>

  </binding>




  <!-- TIME ELAPSED DISPLAY -->




  <binding id="timeelapsed-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">

  <implementation>

    <constructor>
      this.data  = "metadata.position.str";
    </constructor>

   </implementation>

  </binding>




  <!-- GENRE DISPLAY -->




  <binding id="genre-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">

  <implementation>

    <constructor>
      this.data  = "metadata.genre";
    </constructor>

   </implementation>

  </binding>




  <!-- CUSTOM DISPLAY -->



  <binding id="custom-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-compound-label">

  <implementation>

    <constructor>

      // this is a special version of a remote compound label, it takes its value from the preferences
      // and can be configured by the user from a preference pane

      this.setAttribute("value", SBDataGetStringValue("custom.display"));

    </constructor>

   </implementation>

  </binding>




  <!-- NUM PLAYLIST ITEMS DISPLAY -->




  <binding id="numplaylistitems-label" xextends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">

    <content>
      <xul:hbox id="sb-player-numplaylistitems-label" flex="1" xbl:inherits="class">
        <xul:label id="sb-player-numplaylistitems-label-label" sbid="label" xbl:inherits="class,value,align,crop,disabled,flex"/>
      </xul:hbox>
    </content>

    <implementation implements="nsIDOMEventListener,
                                sbIMediaListViewListener,
                                sbIMediaListListener,
                                sbIDeviceEventListener,
                                nsISupportsWeakReference">
      <constructor>
        this.addListeners();
      </constructor>

      <destructor>
        this.removeListeners();
      </destructor>

      <method name="addListeners">
        <body>
          <![CDATA[
            var browser = window.gBrowser;
            if (browser) {
              browser.addEventListener("TabContentChange", this, false);
              browser.tabContainer.addEventListener("ScanProgressChange",
                                                    this, false);
            }
            else {
              let self = this;
              window.addEventListener("load",
                                      function() self.addListeners(), false);
            }
          ]]>
        </body>
      </method>

      <method name="removeListeners">
        <body>
          <![CDATA[
            var browser = window.gBrowser;
            if (browser) {
              browser.removeEventListener("TabContentChange", this, false);
              browser.tabContainer.removeEventListener("ScanProgressChange",
                                                       this, false);
            }

            if (this.previousMediaListView) {
              this.previousMediaListView.removeListener(this);
              this.previousMediaListView.mediaList.removeListener(this);
            }

            if (this.deviceEventTarget) {
              this.deviceEventTarget.removeEventListener(this);
              this.deviceEventTarget = null;
            }
          ]]>
        </body>
      </method>

      <field name="updateDisplayTimeout">null</field>
      <method name="updateDisplayAsync">
        <body>
          <![CDATA[
            // If we have changes following up in quick succession,
            // only update once and asynchronously
            if (this.updateDisplayTimeout)
              window.clearTimeout(this.updateDisplayTimeout);

            this.updateDisplayTimeout = window.setTimeout(function(that) {
              that.updateDisplayTimeout = null;
              that.updateDisplay();
            }, 1000, this);
          ]]>
        </body>
      </method>

      <method name="updateDisplay">
        <body>
          <![CDATA[
            var label = document.getAnonymousElementByAttribute(this, "sbid", "label");
            var displayValue = this.getAttribute('default');

            var browser = window.gBrowser;
            if (!browser) {
              label.setAttribute('value', displayValue);
              return;
            }

            if (browser.mCurrentTab.scanProgress >= 0 &&
                browser.mCurrentTab.scanProgress < 1) {
              // display page scan progress
              var mediafound = SBString("faceplate.mediafound", "Media Found");
              var percent = Math.round(browser.mCurrentTab.scanProgress*100);
              displayValue = mediafound + ': ' + percent + '%';
            } else if (browser.currentMediaListView != null) {
              var mediaListView = browser.currentMediaListView;
              // HOORAY!!  It's okay for mediaListView.length to throw!
              var length = 0;
              try {
                length = mediaListView.length;
              } catch(e) {
                Components.utils.reportError(e);
                length = 0;
              }
              if ( length > 0 ) {
                // display media list length
                displayValue = SBFormattedCountString("faceplate.itemsformat",
                                                      length, [ length ], "");
              }
            }
            label.setAttribute('value', displayValue);
          ]]>
        </body>
      </method>

      <field name="previousMediaListView">null</field>
      <field name="previousDevice">null</field>
      <field name="deviceManager">Cc["@songbirdnest.com/Songbird/DeviceManager;2"]
                                    .getService(Ci.sbIDeviceManager2)</field>
      <field name="deviceEventTarget">null</field>

      <!-- nsIDOMEventListener -->
      <method name="handleEvent">
        <parameter name="event"/>
        <body>
          <![CDATA[
            if (event.type == "TabContentChange") {
              var browser = window.gBrowser;
              var mediaListView = (browser ? browser.currentMediaListView : null);
              if (mediaListView == this.previousMediaListView)
                return;

              if (this.previousMediaListView) {
                this.previousMediaListView.removeListener(this);
                this.previousMediaListView.mediaList.removeListener(this);
              }
              if (mediaListView) {
                const sbIML = Components.interfaces.sbIMediaList;
                mediaListView.addListener(this, true);
                var mediaList = mediaListView.mediaList;
                mediaList.addListener(this, true,
                                      sbIML.LISTENER_FLAGS_ITEMADDED |
                                      sbIML.LISTENER_FLAGS_AFTERITEMREMOVED |
                                      sbIML.LISTENER_FLAGS_LISTCLEARED |
                                      sbIML.LISTENER_FLAGS_BATCHEND);

                var device = this.deviceManager.getDeviceForItem(mediaList);
                if (this.previousDevice != device) {
                  if (this.deviceEventTarget) {
                    this.deviceEventTarget.removeEventListener(this);
                    this.deviceEventTarget = null;
                  }

                  if (device) {
                    this.deviceEventTarget =
                      device.QueryInterface(Ci.sbIDeviceEventTarget);
                    this.deviceEventTarget.addEventListener(this);

                  }
                }
                this.previousDevice = device;
              }
              this.previousMediaListView = mediaListView;

              if (mediaListView)
                this.updateDisplayAsync();
              else
                this.updateDisplay();
            }
            else if (event.type == "ScanProgressChange") {
              // Scan status needs to be updated synchronously
              if (window.gBrowser && event.target == window.gBrowser.mCurrentTab)
                this.updateDisplay();
            }
          ]]>
        </body>
      </method>

      <!-- sbIMediaListViewListener -->
      <method name="onFilterChanged">
        <parameter name="changedView"/>
        <body>
          <![CDATA[
            this.updateDisplay();
          ]]>
        </body>
      </method>
      <method name="onSearchChanged">
        <parameter name="changedView"/>
        <body>
          <![CDATA[
            this.updateDisplay();
          ]]>
        </body>
      </method>
      <method name="onSortChanged">
        <parameter name="changedView"/>
        <body/>
      </method>

      <!-- sbIDeviceEventListener -->
      <method name="onDeviceEvent">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            switch (aEvent.type) {
              case Ci.sbIDeviceEvent.EVENT_DEVICE_TRANSFER_END:
              case Ci.sbIDeviceEvent.EVENT_DEVICE_TRANSCODE_END:
              case Ci.sbIDeviceEvent.EVENT_DEVICE_DOWNLOAD_END:
               this.updateDisplayAsync();
               break;
            }
          ]]>
        </body>
      </method>

      <!-- sbIMediaListListener -->
      <method name="onItemAdded">
        <parameter name="mediaList"/>
        <parameter name="mediaItem"/>
        <parameter name="index"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
      <method name="onAfterItemRemoved">
        <parameter name="mediaList"/>
        <parameter name="mediaItem"/>
        <parameter name="index"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
      <method name="onListCleared">
        <parameter name="mediaList"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
      <method name="onBatchEnd">
        <parameter name="mediaList"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
    </implementation>

  </binding>




  <!-- PLAYER SCANNING DISPLAY -->




  <binding id="scanning-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">

  <implementation>

    <constructor>
      <![CDATA[
        this.setAttribute( "hidden", "true" );
        this.data = "backscan.status";

        this.on_value_change = {
          _that: null,
          observe: function( aSubject, aTopic, aData ) { this._that.onValue( aData ); }
        };
        this.on_value_change._that = this;
        this.bindvalue = SB_NewDataRemote("backscan.concurrent", null);
        this.bindvalue.bindObserver( this.on_value_change, false );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.bindvalue) {
          this.bindvalue.unbind();
          this.bindvalue = null;
        }
      ]]>
    </destructor>

    <method name="onValue">
      <parameter name="aData"/>
      <body>
        <![CDATA[
          if ( parseInt( aData ) > 0  ) {
            this.setAttribute( "hidden", "false" );
          }
          else {
            this.setAttribute( "hidden", "true" );
          }
        ]]>
      </body>
    </method>

   </implementation>

  </binding>



  <!-- JUMP TO CURRENT TRACK BUTTON -->

  <binding id="curtrack-base">

    <implementation>

      <method name="getBrowser">
        <body>
          <![CDATA[
            var retval = null;
            try {
              // Dig through the parent chain to find a happy gBrowser.
              for ( var win = window;
                    win != null && win != win.parent &&
                    typeof win.gBrowser == 'undefined';
                    win = win.parent ) ; // Yes, it is there on purpose.
              if ( win ) {
                retval = win.gBrowser;
              }
            } catch(e) {}
            return retval;
          ]]>
        </body>
      </method>

      <method name="onCurrentTrack">
        <body>
          <![CDATA[
            goDoCommand('cmd_find_current_track');
          ]]>
        </body>
      </method>
    </implementation>
  </binding>

  <binding id="curtrack-button" extends="chrome://songbird/content/bindings/playerControls.xml#curtrack-base">

    <content>
      <xul:hbox id="sb-player-curtrack-button" flex="1" xbl:inherits="hidden,class">
        <xul:button type="sb-clickhold"
                    id="sb-player-curtrack-button-button"
                    oncommand="onCurrentTrack( );"
                    class="sb-player-curtrack-button sb-player-button"
                    tooltiptext="&tooltip.control.curtrack;"
                    xbl:inherits="label,position">
          <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
        </xul:button>
      </xul:hbox>
    </content>

  </binding>

  <binding id="curtrack-box" extends="chrome://songbird/content/bindings/playerControls.xml#curtrack-base">

    <content>
      <xul:box id="sb-player-curtrack-box"
                orient="horizontal"
                mousethrough="never"
                onclick="if (event.button == 0) onCurrentTrack();"
                xbl:inherits="hidden,class,flex,pack,orient">
        <children/>
      </xul:box>
    </content>

  </binding>


  <!-- ENTER FULLSCREEN MODE (WHEN PLAYING VIDEO) -->

  <binding id="fullscreen-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">

    <handlers>
      <handler event="command" action="this.onCommand();"/>
    </handlers>

    <implementation>

      <constructor>
        this.setAttribute("tooltiptext", "&tooltip.fullscreen;");

        // Mac fullscreen coming soon.
        var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                                .getService(Components.interfaces.nsIPropertyBag2);
        if ( sysInfo.getProperty("name") == "Darwin" ) {
          this.setAttribute("hidden", "true");
        }
      </constructor>

      <method name="onCommand">
        <body>
          <![CDATA[
            // XXXAus: Reimplement this when we have video enabled using the new
            //         mediacore api.
          ]]>
        </body>
      </method>

    </implementation>
  </binding>




  <!-- EOF -->
</bindings>
