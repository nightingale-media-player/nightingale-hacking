<?xml version="1.0"?>
<!-- vim: set sw=2 : -->
<!--
/*
//
// BEGIN SONGBIRD GPL
// 
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2008 POTI, Inc.
// http://songbirdnest.com
// 
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
// 
// Software distributed under the License is distributed 
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either 
// express or implied. See the GPL for the specific language 
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this 
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc., 
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
// 
// END SONGBIRD GPL
//
 */
-->

<!DOCTYPE bindings SYSTEM "chrome://songbird/locale/songbird.dtd" >

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">


  
  
  <!-- VOLUME CONTROL -->

  
  
  
  <binding id="volume-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

    <handlers>
      <handler event="progressSliderChange" action="this.onTrackVolume();"/>
      <handler event="progressSliderRelease" action="this.onReleaseVolume();"/>
    </handlers>

  <implementation>

    <constructor>
        /* outside CDATA to get localized entity */
        this.setAttribute("tooltiptext", "&tooltip.control.volume;");
      <![CDATA[
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.className += " sb-player-volume-slider";
      
        // Then do the rest of your crap
        this.mm = 
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // data remotes
        const on_remote_volume_change = { 
          _that: this, 
          observe: function volumeSlider_onChange( aSubject, aTopic, aData ) {
            this._that.onRemoteVolumeChange();
          } 
        };
        this.remote_volume = SB_NewDataRemote( "faceplate.volume", null );
        this.remote_volume.bindObserver(on_remote_volume_change, true);

        this.remote_lastVolume = SB_NewDataRemote("faceplate.volume.last", null );
        
        const on_remote_mute = { 
          _that: this, 
          observe: function volumeSlider_onChange( aSubject, aTopic, aData ) {
            this._that.onRemoteMute(aData);
          } 
        };
        this.remote_mute = SB_NewDataRemote( "faceplate.mute", null );
        this.remote_mute.bindObserver(on_remote_mute, true);

        this.sliderScale = 10000;
        this.maxpos = this.sliderScale;
        this.value = parseFloat(this.remote_volume.stringValue) * this.sliderScale;
        this.trackingVolume = false;
        
        // initialize lastValue if it wasn't set
        if (this.remote_lastVolume.stringValue == "") {
          this.lastValue = this.value;
        }
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.remote_volume) {
          this.remote_volume.unbind();
          this.remote_volume = null;
        }
        if (this.remote_lastVolume) {
          this.remote_lastVolume = null;
        }
        if (this.remote_mute) {
          this.remote_mute.unbind();
          this.remote_mute = null;
        }
        
        this.mm = null;
      ]]>
    </destructor>
    
    <method name="onTrackVolume">
      <body>
        <![CDATA[
          if (this.getAttribute("disabled"))
            return;
          // prevent this volume control from being updated while it is being
          // moved (but other volume controls are updated with our motion)
          this.trackingVolume = true; 
          var scaledValue = this.value / this.sliderScale;
          this.mm.volumeControl.volume = scaledValue;

          this.remote_volume.stringValue = scaledValue;
          // set to mute when we're at zero
          this.mm.volumeControl.mute = (this.value == 0);
        ]]>
      </body>
    </method>

    <method name="onReleaseVolume">
      <body>
        <![CDATA[
          if (this.getAttribute("disabled"))
            return;
          this.trackingVolume = false;
          this.mm.volumeControl.volume = this.value / this.sliderScale;
        ]]>
      </body>
    </method>

    <method name="onRemoteVolumeChange">
      <body>
        <![CDATA[
          if (this.getAttribute("disabled"))
            return;
          try {
            this.value = parseFloat(this.remote_volume.stringValue) * this.sliderScale;
          } catch (err) {
            dump("playerControls.xml - onRemoteVolumeChange - " + err + "\n");
          }
        ]]>
      </body>
    </method>

    <method name="onRemoteMute">
      <body>
        <![CDATA[
          if (this.getAttribute("disabled"))
            return;
          // the mute state changed
          if (this.remote_mute.boolValue) {
            if (this.value != 0) {
              this.lastValue = this.value;
            }
            this.remote_volume.intValue = 0;
            this.value = 0;
          } else {
            var lastValue = this.lastValue / this.sliderScale;
            this.mm.volumeControl.volume = this.lastValue / this.sliderScale;
          }
        ]]>
      </body>
    </method>
    
    <!-- override the values in the progress slider to make it track the volume -->
    <property name="lastValue">
      <getter>
        return parseFloat(this.remote_lastVolume.stringValue) * this.sliderScale;
      </getter>
      <setter>
        this.remote_lastVolume.stringValue = val / this.sliderScale;
      </setter>
    </property>

   </implementation>
 
  </binding>




  <!-- MUTE CONTROL -->



  <binding id="mute-button">
  
    <content>
      <xul:hbox id="sb-player-mute-button" oncommand="onMute();" flex="1">
        <xul:button type="sb-clickhold"
                    hidden="false"
                    id="sb-player-mute-button-muteoff"
                    class="sb-player-mute-button-muteoff sb-player-button"
                    sbid="mute-off"
                    tooltiptext="&tooltip.control.mute;"
                    xbl:inherits="label,position">
          <xul:observes type="dataremote"
                    key="faceplate.mute" 
                    attribute="hidden" 
                    boolean="true"
                    inverted="false" />
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="sb-player-mute-menu-muteoff" 
                          autocheck="false" 
                          checked="false" 
                          class="menuitem-iconic" 
                          type="radio" 
                          label="&tooltip.control.mute;"/>
          </xul:menupopup>
        </xul:button>
        <xul:button type="sb-clickhold"
                    hidden="false"
                    id="sb-player-mute-button-muteon"
                    class="sb-player-mute-button-muteon sb-player-button"
                    sbid="mute-on" tooltiptext="&tooltip.control.mute;"
                    xbl:inherits="label,position">
          <xul:observes type="dataremote"
                    key="faceplate.mute" 
                    attribute="hidden" 
                    boolean="true"
                    inverted="true" />  
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="sb-player-mute-menu-muteon" 
                          autocheck="false" 
                          checked="true" 
                          class="menuitem-iconic" 
                          type="radio" 
                          label="&tooltip.control.mute;"/>
          </xul:menupopup>
        </xul:button>
      </xul:hbox>
    </content>

    <implementation>

    <constructor>
      <![CDATA[
        this.mm = 
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // Create and bind the data remotes
        this.remote_mute = SB_NewDataRemote( "faceplate.mute", null );

        // observer for DataRemote 
        const on_remote_mute = { 
          _that: this, 
          observe: function dr_onMuteToggle( aSubject, aTopic, aData ) {
            this._that.onRemoteMute();
          } 
        };
        this.remote_mute.bindObserver(on_remote_mute, true);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        // Release the data remotes
        if (this.remote_mute) {
          this.remote_mute.unbind();
          this.remote_mute = null;
        }
        this.mm = null;
      ]]>
    </destructor>

    <field name="mute_on">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-on');</field>
    <field name="mute_off">document.getAnonymousElementByAttribute(this, 'sbid', 'mute-off');</field>

    <method name="onMute">
      <body>
        <![CDATA[
          // Yikes.  If we hide the clickholdbutton because of the popupmenu,
          // the popupmenu gets broken.  Therefore, we wait until the next UI
          // frame to change the mute state.
          var that = this;
          setTimeout( function() { that.doMute() }, 0 );
        ]]>
      </body>
    </method>

    <method name="doMute">
      <body>
        <![CDATA[
          if (this.getAttribute("disabled"))
            return;
          this.mm.volumeControl.mute = !this.mm.volumeControl.mute;
          // this will trigger onRemoteMute due to the data remote
        ]]>
      </body>
    </method>

    <method name="onRemoteMute">
      <body>
        <![CDATA[
          if (this.getAttribute("disabled"))
            return;
          var newmute = this.mm.volumeControl.mute;
          if (!newmute) {
            // restore last volume when coming back from mute state
            this.mm.volumeControl.volume = 
              parseFloat(this.remote_lastVolume.stringValue);
          } 
          else {
            if (parseFloat(this.remote_volume.stringValue) != 0) {
              this.remote_lastVolume.stringValue = this.remote_volume.stringValue;
            }
            this.mm.volumeControl.volume = 0;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  <!-- BASECLASS BINDINGS FOR SONGBIRD OVERLAY TRICKS
  
  These bindings will set some magic values inside of the objects we inherit from xpfe.
  
  It places the nodename as the id on the inner hbox for XBL Overlay and adds a class
  value that may be used in the CSS.
  
  -->
  <binding id="sb-button-base" extends="chrome://global/content/bindings/button.xml#button">
    <implementation>
      <constructor>
      <![CDATA[
        // ENFORCE CLICKABILITY!  (why do I have to do this?)
        this.setAttribute("mousethrough","never");
        
        // Get the nodename (without the namespace)
        var nameArray = this.nodeName.split(":");
        var nodeName = ( nameArray.length > 1 ) ? nameArray[ 1 ] : nameArray[ 0 ];
        
        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        var box = document.getAnonymousElementByAttribute(this, "class", "box-inherit button-box");
        box.setAttribute( 'id', nodeName );
        
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " sb-player-button " + nodeName);
      ]]>
      </constructor>
    </implementation>
  </binding>

  <binding id="sb-checkbox-base" extends="chrome://global/content/bindings/checkbox.xml#checkbox-baseline">
    <implementation>
      <constructor>
      <![CDATA[
        // ENFORCE CLICKABILITY!  (why do I have to do this?)
        this.setAttribute("mousethrough","never");
        
        // Get the nodename (without the namespace)
        var nameArray = this.nodeName.split(":");
        var nodeName = ( nameArray.length > 1 ) ? nameArray[ 1 ] : nameArray[ 0 ];
        
        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        var box = document.getAnonymousElementByAttribute(this, "class", "checkbox-label-box");
        box.setAttribute( 'id', nodeName );
        
        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " " + nodeName);
      ]]>
      </constructor>
    </implementation>
  </binding>


  <!-- FORWARD BUTTON-->

  
  
  
  <binding id="forward-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">

  <handlers>
    <handler event="mousedown" button="0" action="this.onFwdMouseDown();"/>
    <handler event="mouseup" button="0" action="this.onFwdMouseUp();"/>
    <handler event="mouseout" action="this.onFwdMouseOut();"/>
    <handler event="mouseover" action="this.onFwdMouseOver();"/>
  </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.fwd;")
      <![CDATA[
        this.mm = 
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        this.mm = null;
      ]]>
    </destructor>
    
    <method name="onFwdMouseDown">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          var sbIMediacoreStatus = Components.interfaces.sbIMediacoreStatus;
          this.seen_skip = false;
          if ( this.mm.status.state == sbIMediacoreStatus.STATUS_PLAYING)
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOut">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          if (this.skip_interval) {
            clearInterval( this.skip_interval );
            this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseOver">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          if (this.skip && !this.skip_interval ) {
             document.__SKIPLOOPOBJECT__ = this;
             this.skip_interval = setInterval( this.skipLoop, 1000 );
          }
        ]]>
      </body>
    </method>

    <method name="onFwdMouseUp">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.skip = false;
          this.onFwdCommand();
        ]]>
      </body>
    </method>

    <method name="onFwdCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.mm.sequencer.next();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          if ( _this.skip )
          {
            // If we're allowed to skip
            if ( _this.mm.playbackControl.duration > 0 )
            {
              _this.seen_skip = true;
              var target = _this.mm.playbackControl.position + 15000;
              var max = _this.mm.playbackControl.duration - 1000;
              _this.mm.playbackControl.position = ( max < target ) ? max : target;
            }
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- BACK BUTTON-->

  
  
  
  <binding id="back-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">

   <handlers>
     <handler event="mousedown" button="0" action="this.onBackMouseDown();"/>
     <handler event="mouseup" button="0" action="this.onBackMouseUp();"/>
     <handler event="mouseout" action="this.onBackMouseOut();"/>
     <handler event="mouseover" action="this.onBackMouseOver();"/>
   </handlers>

  <implementation>

    <constructor>
        this.setAttribute("tooltiptext", "&tooltip.control.back;")
      <![CDATA[
        this.mm = 
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        this.seen_skip = false;
        this.skip = false;
        this.skip_interval = null;
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        this.mm = null;
      ]]>
    </destructor>
    
    <method name="onBackMouseDown">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          var sbIMediacoreStatus = Components.interfaces.sbIMediacoreStatus;
          this.seen_skip = false;
          var status = this.mm.status;
          if ( status.state == sbIMediacoreStatus.STATUS_PLAYING)
          {
            this.skip = true;
            if ( ! this.skip_interval )
            {
              document.__SKIPLOOPOBJECT__ = this;
              this.skip_interval = setInterval( this.skipLoop, 1000 );
            }
          }
        ]]>
      </body>
    </method>

    <method name="onBackMouseUp">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.skip = false;
          this.onBackCommand();
        ]]>
      </body>
    </method>

    <method name="onBackMouseOut">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          if (this.skip_interval) {
            clearInterval( this.skip_interval );
            this.skip_interval = null;
           }
        ]]>
      </body>
    </method>

    <method name="onBackMouseOver">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          if (this.skip && !this.skip_interval ) {
             document.__SKIPLOOPOBJECT__ = this;
             this.skip_interval = setInterval( this.skipLoop, 1000 );
          }
        ]]>
      </body>
    </method>

    <method name="onBackCommand">
      <body>
        <![CDATA[
          if ( !this.seen_skip )
          {
            this.mm.sequencer.previous();
          }
        ]]>
      </body>
    </method>

    <method name="skipLoop">
      <body>
        <![CDATA[
          var _this = document.__SKIPLOOPOBJECT__;
          var playbackControl = _this.mm.playbackControl;
          if ( _this.skip )
          {
            _this.seen_skip = true;
            var target = playbackControl.position - 15000;
            playbackControl.position = ( target > 1 ) ? target : 1;
          }
          else
          {
            clearInterval( _this.skip_interval );
            _this.skip_interval = null;
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- REPEAT CONTROL -->




  <binding id="repeat-button">
  
   <content>
     <xul:stack id="sb-player-repeat-button" xbl:inherits="class=class" >
       <xul:button type="sb-clickhold"
                   id="repeat_none"
                   class="sb-player-repeat-button-repnone sb-player-button"
                   oncommand="onRepeat(event.target);"
                   tooltiptext="&menu.control.repx;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.repeat" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 0" />
         <xul:menupopup xbl:inherits="popupanchor,popupalign">  
          <xul:menuitem id="menu_repeat_none" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
          <xul:menuitem id="menu_repeat_all" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
          <xul:menuitem id="menu_repeat_1" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
         </xul:menupopup>
       </xul:button>
       <xul:button type="sb-clickhold"
                   id="repeat_1"
                   class="sb-player-repeat-button-rep1 sb-player-button"
                   oncommand="onRepeat(event.target);"
                   tooltiptext="&menu.control.rep1;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.repeat" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 1" />
          <xul:menupopup xbl:inherits="popupanchor,popupalign">  
            <xul:menuitem id="menu_repeat_none" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
            <xul:menuitem id="menu_repeat_all" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
            <xul:menuitem id="menu_repeat_1" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
          </xul:menupopup>
       </xul:button>
       <xul:button type="sb-clickhold"
                   id="repeat_all"
                   class="sb-player-repeat-button-repall sb-player-button"
                   oncommand="onRepeat(event.target);"
                   tooltiptext="&menu.control.repa;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.repeat" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 2" />
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="menu_repeat_none" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.repx;"/>
            <xul:menuitem id="menu_repeat_all" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&menu.control.repa;"/>
            <xul:menuitem id="menu_repeat_1" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&menu.control.rep1;"/>
          </xul:menupopup>
       </xul:button>
     </xul:stack>
   </content>

  <implementation>
    <property name="disabled"
              onset="if (val) this.setAttribute('disabled', 'true');
                     else this.removeAttribute('disabled');
                     return val;"
              onget="return this.hasAttribute('disabled');" />

    <constructor>
      <![CDATA[
        this.mm = 
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // Create and bind data remotes
        this.remote_repeat = SB_NewDataRemote( "playlist.repeat", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "repeat binding destructor");
        if (this.remote_repeat) {
          this.remote_repeat.unbind();
          this.remote_repeat = null;
        }
        
        if(this.mm) {
          this.mm = null;
        }
      ]]>
    </destructor>

    <field name="repeat_none">document.getAnonymousElementByAttribute(this, 'id', 'repeat_none');</field>
    <field name="repeat_1">document.getAnonymousElementByAttribute(this, 'id', 'repeat_1');</field>
    <field name="repeat_all">document.getAnonymousElementByAttribute(this, 'id', 'repeat_all');</field>

    <method name="onRepeat">
      <parameter name="target"/>
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          var value = 0;
          switch( target.id )
          {
            case "menu_repeat_none": 
              value = 0;
              break;
            case "menu_repeat_1": 
              value = 1;
              break;
            case "menu_repeat_all":
              value = 2;
              break;
            default:
              switch ( this.remote_repeat.intValue )
              {
                case (0): // Apparently, "case 0:" != "case (0):" ?!?!?
                  value = 2;
                  break;
                case (1): // BUT, "case 1:" == "case (1):" ?!?!?
                  value = 0;
                  break;
                case (2):
                  value = 1;
                  break;
              }
              break;
          }
          
          this.mm.sequencer.repeatMode = value;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
  <!-- SHUFFLE CONTROL -->




  <binding id="shuffle-button">
  
   <content>
     <xul:stack id="sb-player-shuffle-button" xbl:inherits="class=class" oncommand="onShuffle( );">
       <xul:button type="sb-clickhold"
                   id="sb-player-shuffle-button-off"
                   sbid="shuffle_off"
                   class="sb-player-shuffle-button-off sb-player-button"
                   tooltiptext="&tooltip.control.shuf_off;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.shuffle" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 0" />  
         <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="menu_shuffle_off" autocheck="false" checked="false" class="menuitem-iconic" type="radio" label="&tooltip.control.shuffle;"/>
         </xul:menupopup>
       </xul:button>
       <xul:button type="sb-clickhold"
                   id="sb-player-shuffle-button-on"
                   sbid="shuffle_on"
                   class="sb-player-shuffle-button-on sb-player-button"
                   tooltiptext="&tooltip.control.shuffle;"
                   xbl:inherits="label,position">
         <xul:observes type="dataremote"
                   key="playlist.shuffle" 
                   attribute="hidden" 
                   onchange="return parseInt( value ) != 1" />
         <xul:menupopup xbl:inherits="popupanchor,popupalign">  
          <xul:menuitem id="menu_shuffle_on" autocheck="false" checked="true" class="menuitem-iconic" type="radio" label="&tooltip.control.shuffle;"/>
         </xul:menupopup>
       </xul:button>
     </xul:stack>
   </content>

  <implementation>
    <property name="disabled"
              onset="if (val) this.setAttribute('disabled', 'true');
                     else this.removeAttribute('disabled');
                     return val;"
              onget="return this.hasAttribute('disabled');" />

    <constructor>
      <![CDATA[
        this.mm = 
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // Create and bind data remotes
        this.remote_shuffle = SB_NewDataRemote( "playlist.shuffle", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "shuffle binding destructor");
        if(this.remote_shuffle) {
          this.remote_shuffle.unbind();
          this.remote_shuffle = null;
        }
        
        if(this.mm) {
          this.mm = null;
        }
      ]]>
    </destructor>

    <field name="shuffle_off">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_off');</field>
    <field name="shuffle_on">document.getAnonymousElementByAttribute(this, 'sbid', 'shuffle_on');</field>
    
    <method name="onShuffle">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.mm.sequencer.mode = 
            !this.remote_shuffle.boolValue ? 
            this.mm.sequencer.MODE_SHUFFLE : 
            this.mm.sequencer.MODE_FORWARD;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>


  
  
  <!-- SEEK CONTROL -->

  
  
  
  <binding id="seek-slider" extends="chrome://songbird/content/bindings/progressSlider.xml#progress-slider">

   <handlers>
     <handler event="progressSliderChange" action="this.onTrackSeekbar();"/>
     <handler event="progressSliderRelease" action="this.onReleaseSeekbar();"/>
   </handlers>

  <implementation>

    <constructor>
      <![CDATA[
        // OVERLAY TARGET ID MATCHES ELEMENT NAME
        this.box.setAttribute("id", "sb-player-seek-slider" );

        // ADD EXTRA CSS CLASS FOR ANONYMOUS OBJECTS
        this.setAttribute("class", this.getAttribute("class") + " sb-player-seek-slider");

        this.mm = 
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // observer for DataRemote 
        const on_remote_position_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onRemotePositionChange(); } 
        };
        on_remote_position_change._that = this;

        // Create and bind data remotes
        this.remote_position = SB_NewDataRemote( "metadata.position", null );
        this.remote_position.bindObserver(on_remote_position_change, true);
        this.remote_length = SBDataBindElementAttribute( "metadata.length", this, "maxpos" );
       
        this.trackingPosition = 0;
        this.scrubbingPosition = false;
        this.seekInProgress = false;
        this.wasPlayingBeforeSeek = false;
        this.hasVideo = false;

        this.eventListener = {
          that: this,
          onMediacoreEvent: function(aEvent) {
            if (aEvent.type == aEvent.STREAM_PAUSE) {
              this.that.seekInProgress = false;
            }
            else if (aEvent.type == aEvent.STREAM_HAS_VIDEO) {
              this.that.hasVideo = true;
            }
            else if (aEvent.type == aEvent.TRACK_CHANGE) {
              this.that.hasVideo = false;
            }
          }
        }

        this.mm.addListener(this.eventListener);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "seek-slider binding destructor");
        if (this.remote_position) {
          this.remote_position.unbind();
          this.remote_position = null;
        }
        if (this.remote_length) {
          this.remote_length.unbind();
          this.remote_length = null;
        }
        
        this.mm.removeListener(this.eventListener);
        this.mm = null;
      ]]>
    </destructor>

    <method name="onTrackSeekbar">
      <body>
        <![CDATA[
          if (!this.trackingPosition) {
            this.trackingPosition = 1;

            // We do scrubbing for video only.
            if (this.hasVideo) {
              this.scrubbingPosition = true;
              if (this.mm.status.state ==
                  Components.interfaces.sbIMediacoreStatus.STATUS_PLAYING) {
                this.wasPlayingBeforeSeek = true;
              }
              else {
                this.wasPlayingBeforeSeek = false;
              }
              this.mm.playbackControl.pause();
            }
          }

          // Seek while tracking if we're scrubbing. Don't start a seek
          // unless the previous one completed, otherwise we never make
          // any progress...
          if (this.scrubbingPosition && !this.seekInProgress) {
            try {
              this.mm.playbackControl.position = this.progress_value;
              this.seekInProgress = true;
            } catch(e) {
              // Seeking failed; disable scrubbing.
              this.scrubbingPosition = false;
              if (this.wasPlayingBeforeSeek)
                this.mm.playbackControl.play();
            }
          }
        ]]>
      </body>
    </method>

    <method name="onReleaseSeekbar">
      <body>
        try {
          // Setting the position may fail if the format doesn't support
          // seeking or if http resuming does not work.
          this.mm.playbackControl.position = this.value;

          this.seekInProgress = false;
          if (this.scrubbingPosition) {
            this.scrubbingPosition = false;
            if (this.wasPlayingBeforeSeek) {
              this.mm.playbackControl.play();
            }

          }
        }
        catch(e) {
          Components.utils.reportError(e);
        }
        this.trackingPosition = 0;
      </body>
    </method>

    <method name="onRemotePositionChange">
      <body>
        <![CDATA[
          // if we are the control changing the position, ignore this callback
          if (this.trackingPosition) 
            return; 
            
          this.value = this.remote_position.intValue;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  
  
  
 
  <!-- PLAYPAUSE/PLAY/PAUSE/STOP CONTROLS -->


  <binding id="play-control-base">

    <implementation>

      <constructor>
        <![CDATA[
        if (typeof(ColumnSpecParser) == "undefined") {
          Components.utils.import("resource://app/jsmodules/sbColumnSpecParser.jsm");
          if (!ColumnSpecParser)
            throw new Error("Import of sbColumnSpecParser module failed");
        }
        this.mm = 
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);
                    
        ]]>
      </constructor>
      <destructor>
        <![CDATA[
          this.mm = null;
        ]]>
      </destructor>
                     
      <method name="playbackPlay">
        <parameter name="nopause"/>
        <body>
          <![CDATA[
            // If we are already playing something just pause/unpause playback
            var status = this.mm.status;
            var sbIMediacoreStatus = Components.interfaces.sbIMediacoreStatus;
            if (status.state == sbIMediacoreStatus.STATUS_PAUSED || nopause) {
              this.mm.playbackControl.play();
            } else if(status.state == sbIMediacoreStatus.STATUS_PLAYING || 
                      status.state == sbIMediacoreStatus.STATUS_BUFFERING) {
              this.mm.playbackControl.pause();
            
            // Otherwise dispatch a play event.  Someone should catch this
            // and intelligently initiate playback.  If not, just have
            // the playback service play the default.
            } else {
              var event = document.createEvent("Events");
              event.initEvent("Play", true, true);
              var notHandled = this.dispatchEvent(event);
              if (notHandled) {
                // If we have no context, initiate playback
                // via the root application controller
                var app = Components.classes["@songbirdnest.com/Songbird/ApplicationController;1"]
                                    .getService(Components.interfaces.sbIApplicationController);
                app.playDefault();
              }
            }
          ]]>
        </body>
      </method>

      <method name="playbackPause">
        <body>
          <![CDATA[
            this.mm.playbackControl.pause();
          ]]>
        </body>
      </method>

      <method name="playbackStop">
        <body>
          <![CDATA[
            this.mm.sequencer.stop();
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>


  <!-- a play button, always enabled because it is legitimate to restart playback in the middle of playback -->

  <binding id="play-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-play-button" flex="1" xbl:inherits="hidden,class">
      
        <xul:button type="sb-clickhold"
                    id="sb-player-play-button-play"
                    sbid="play"
                    class="sb-player-play-button-play sb-player-button"
                    oncommand="onPlay();"
                    tooltiptext="&tooltip.control.play;"
                    xbl:inherits="label,position">
          <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
        </xul:button>
          
      </xul:hbox>
    </content>

  <implementation>

    <method name="onPlay">
      <body>
        this.playbackPlay(true);
      </body>
    </method>

   </implementation>
 
  </binding>


  <!-- a pause/restore button -->

  <binding id="pause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-pause-button" flex="1" xbl:inherits="hidden,class">
        <xul:stack xbl:inherits="class=class" >
        
          <xul:button type="sb-clickhold"
                      id="sb-player-pause-button-pause"
                      sbid="pause"
                      class="sb-player-pause-button-pause sb-player-button"
                      onmousedown="onPause();"
                      tooltiptext="&tooltip.control.pause;"
                      xbl:inherits="label,position">
            
            <xul:observes type="dataremote"
                      key="faceplate.playing" 
                      attribute="disabled" 
                      boolean="true"
                      inverted="true"/>  
            <xul:observes type="dataremote"
                      key="faceplate.paused" 
                      attribute="hidden" 
                      boolean="true"
                      inverted="false"/>
                      
            <xul:menupopup xbl:inherits="popupanchor,popupalign"/>  
          </xul:button>
          
          <xul:button type="sb-clickhold"
                      id="sb-player-pause-button-resume" 
                      sbid="resume" 
                      class="sb-player-pause-button-resume sb-player-button" 
                      oncommand="onPlay();" 
                      tooltiptext="&tooltip.control.resume;" 
                      xbl:inherits="label,position">
            
            <xul:observes type="dataremote"
                      key="faceplate.playing" 
                      attribute="disabled" 
                      boolean="true"
                      inverted="true"/>  
            <xul:observes type="dataremote"
                      key="faceplate.paused" 
                      attribute="hidden" 
                      boolean="true"
                      inverted="true"/>  
            <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
          </xul:button>
          
        </xul:stack>
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>
    <field name="resume">document.getAnonymousElementByAttribute(this, 'sbid', 'resume');</field>

    <method name="onPause">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackPause();
        ]]>
      </body>
    </method>

    <method name="onPlay">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackPlay();
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>

  <!-- a stop button that enables itself when the core is playing, and disables itself when the core is stopped -->

  <binding id="stop-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-stop-button" flex="1" xbl:inherits="hidden,class">
      
        <xul:button type="sb-clickhold"
	            id="sb-player-stop-button-stop"
	            sbid="stop"
	            class="sb-player-stop-button-stop sb-player-button"
	            oncommand="onStop();"
	            tooltiptext="&tooltip.control.stop;"
	            xbl:inherits="label,position">
          
          <xul:observes type="dataremote"
		                    key="faceplate.playing" 
		                    attribute="disabled" 
		                    boolean="true"
		                    inverted="true" />
         <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
        </xul:button>
        
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
      ]]>
    </destructor>

    <field name="stop">document.getAnonymousElementByAttribute(this, 'sbid', 'stop');</field>

    <method name="onStop">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackStop();
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <binding id="playpause-button" extends="chrome://songbird/content/bindings/playerControls.xml#play-control-base">
  
    <content>
      <xul:hbox id="sb-player-playpause-button" flex="1" xbl:inherits="hidden,class,disabled">
      
        <xul:button type="sb-clickhold"
                    id="sb-player-playpause-button-play"
                    sbid="play"
                    class="sb-player-playpause-button-play sb-player-button"
                    oncommand="onPlayPause(event.target);"
                    tooltiptext="&tooltip.control.play;"
                    xbl:inherits="label,position,disabled"
                    onmenushowing="syncMenus();">
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
            <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
            <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
            <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
          </xul:menupopup>
        </xul:button>
        
        <xul:button type="sb-clickhold"
		    id="sb-player-playpause-button-pause"
		    sbid="pause"
                    class="sb-player-playpause-button-pause sb-player-button"
                    oncommand="onPlayPause(event.target);"
                    tooltiptext="&tooltip.control.pause;"
                    xbl:inherits="label,position,disabled"
                    onmenushowing="syncMenus();">
          <xul:menupopup xbl:inherits="popupanchor,popupalign">
	          <xul:menuitem id="menu_play" class="menuitem-iconic" label="&menu.control.play.button;"/>
	          <xul:menuitem id="menu_pause" class="menuitem-iconic" label="&menu.control.pause.button;"/>
	          <xul:menuitem id="menu_stop" class="menuitem-iconic" label="&menu.control.stop.button;"/>
	        </xul:menupopup>
        </xul:button>
        
      </xul:hbox>
    </content>

  <implementation>

    <constructor>
      <![CDATA[
        // observer for DataRemote 
        this.on_state_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onStateChanged(); } 
        };
        this.on_state_change._that = this;
        this.remote_playing = SB_NewDataRemote("faceplate.playing", null);
        this.remote_paused = SB_NewDataRemote("faceplate.paused", null);
        this.remote_playing.bindObserver(this.on_state_change, false);
        this.remote_paused.bindObserver(this.on_state_change, false);
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        this.remote_playing.unbind();
        this.remote_paused.unbind();
      ]]>
    </destructor>

    <field name="play">document.getAnonymousElementByAttribute(this, 'sbid', 'play');</field>
    <field name="pause">document.getAnonymousElementByAttribute(this, 'sbid', 'pause');</field>

    <method name="onStateChanged">
      <body>
        <![CDATA[
          if (this.remote_playing.boolValue && !this.remote_paused.boolValue) { 
            this.play.hidden = true; 
            this.pause.hidden = false; 
          } else { 
            this.play.hidden = false; 
            this.pause.hidden = true; 
          }
        ]]>
      </body>
    </method>
    
    <method name="syncMenus">
      <body>
        this.syncMenu(this.play);
        this.syncMenu(this.pause);
      </body>
    </method>
    
    <method name="syncMenu">
      <parameter name="parent"/>
      <body>
        <![CDATA[
          var sbIMediacoreStatus = Components.interfaces.sbIMediacoreStatus;
          var status = this.mm.status;
          for (var i=0;i<parent.childNodes.length;i++) {
            var node = parent.childNodes[i];
            switch (node.id) {
              case "menu_play":
                // play is disabled if we are already playing but we are not also paused (playing remains true while we are paused!)
                node.disabled = (status.state == sbIMediacoreStatus.STATUS_PLAYING);
                break;
              case "menu_pause":
                // pause is disabled if we are already paused, or if we are stopped
                node.disabled = (status.state == sbIMediacoreStatus.STATUS_PAUSED ||
                                 status.state != sbIMediacoreStatus.STATUS_PLAYING);
                break;
              case "menu_stop":
                // stop is disabled if we are already stopped (ie, the playbutton is visible, but we are not paused)
                node.disabled = (status.state == sbIMediacoreStatus.STATUS_STOPPED);
                break;
            }
          }
        ]]>
      </body>
    </method>

    <method name="onPlay">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackPlay();
        ]]>
      </body>
    </method>
    
    <method name="onPause">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackPause();
        ]]>
      </body>
    </method>

    <method name="onStop">
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          this.playbackStop();
        ]]>
      </body>
    </method>
    
    <method name="onPlayPause">
      <parameter name="target"/>
      <body>
        <![CDATA[
          if (this.disabled)
            return;
          var sbid = target.getAttribute("sbid");
          if (sbid == "play") this.onPlay();
          else if (sbid == "pause") this.onPause();
          else {
            switch (target.id) {
              case "menu_play": this.onPlay(); break; 
              case "menu_pause": this.onPause(); break;
              case "menu_stop": this.onStop(); break;
            }
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <!-- CONTROL PANE BUTTONS BLOCK -->

  <binding id="control-buttons">

    <content>
      <xul:hbox id="sb-player-control-buttons" flex="1" xbl:inherits="class,hidden">
        <xul:sb-player-back-button id="sb-player-control-buttons-back" class="sb-player-button" xbl:inherits="class"/>
        <!-- Bonus Buttons!
          <xul:sb-player-pause-button id="sb-player-control-buttons-pause" popupanchor="topleft" popupalign="bottomleft"/>
          <xul:sb-player-play-button id="sb-player-control-buttons-play" popupanchor="topleft" popupalign="bottomleft"/>
          <xul:sb-player-stop-button id="sb-player-control-buttons-stop" popupanchor="topleft" popupalign="bottomleft"/>
        -->
        <xul:sb-player-playpause-button id="sb-player-control-buttons-playpause" class="sb-player-button" xbl:inherits="class" popupanchor="topleft" popupalign="bottomleft"/>
        <xul:sb-player-forward-button id="sb-player-control-buttons-forward" class="sb-player-button" xbl:inherits="class"/> 
      </xul:hbox>
    </content>
  
    <implementation>
      <constructor>
      </constructor>
    </implementation>
 
  </binding>



  <!-- TOTALTIME DISPLAY -->

  <binding id="totaltime-label">
  
    <content>
      <xul:hbox id="sb-player-totaltime-label" flex="1" xbl:inherits="class,align,crop,disabled,flex">
        <xul:label sbid="timelabel" xbl:inherits="class,align,crop,disabled,flex" mousethrough="never">
          <xul:observes type="dataremote"
                    key="metadata.length.str" 
                    attribute="value"/>  
        </xul:label>
      </xul:hbox>
    </content>

    <handlers>
      <handler event="mousedown" action="this.onTotalDown();"/>
    </handlers>


  <implementation>

    <constructor>
      <![CDATA[
        this.mm = 
          Components.classes["@songbirdnest.com/Songbird/Mediacore/Manager;1"]
                    .getService(Components.interfaces.sbIMediacoreManager);

        // Create and bind data remote
        this.remote_showRemaining = SB_NewDataRemote( "faceplate.showremainingtime", null );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        //SB_LOG("playerControls.js", "totaltime binding destructor");
        this.remote_showRemaining = null;
        
        this.mm = null;
      ]]>
    </destructor>

    <method name="onTotalDown">
      <body>
        <![CDATA[
          var len = this.mm.playbackControl.duration;
          if ( len > 0 )
            this.remote_showRemaining.boolValue = !this.remote_showRemaining.boolValue;
          // If you try to toggle it while it is zero, you lose the state.
          else
            this.remote_showRemaining.boolValue = false;
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <!-- ARTIST DISPLAY -->


  <binding id="artist-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
    <implementation>

      <constructor>
        this.data  = "metadata.artist";
      </constructor>

    </implementation>
 
  </binding>



  <!-- TITLE DISPLAY -->


  <binding id="title-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.data  = "metadata.title";
        this.autotip = this.getAttribute("autotip");
        if (this.autotip) {
          // observer for DataRemote 
          this.on_remote_artist_album_change = { 
            _that: null, 
            observe: function( aSubject, aTopic, aData ) { 
              try {
                this._that.rebuildTip(); 
              }
              catch(e) {}
            } 
          };
          this.on_remote_artist_album_change._that = this;

          // Create and bind data remotes
          this.remote_artist = SB_NewDataRemote( "metadata.artist", null );
          this.remote_album = SB_NewDataRemote( "metadata.album", null );
          this.remote_artist.bindObserver(this.on_remote_artist_album_change, true);
          this.remote_album.bindObserver(this.on_remote_artist_album_change, true);

          this.rebuildTip();
        }
      ]]>
    </constructor>

    <destructor>
      <![CDATA[
        this.on_remote_artist_album_change = null;
        if (this.remote_album) {
          this.remote_album.unbind();
          this.remote_album = null;
        }
        if (this.remote_artist) {
          this.remote_artist.unbind();
          this.remote_artist = null
        }
      ]]>
    </destructor>

    <method name="rebuildTip">
      <body>
        <![CDATA[
          try {
            var tip = "";
            if ( this.remote_artist.stringValue &&
                 this.remote_artist.stringValue.length ) {
              tip = this.remote_artist.stringValue;
            }
            if ( this.remote_album.stringValue &&
                 this.remote_album.stringValue.length ) {
              if (tip.length > 0) tip += " / ";
              tip += this.remote_album.stringValue;
            }
            this.label.setAttribute("tooltiptext", tip);
          } catch (e) {
            alert("playerControls.xml - rebuildTip - " + e);
          }
        ]]>
      </body>
    </method>

   </implementation>
 
  </binding>



  <!-- ALBUM DISPLAY -->


  <binding id="album-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.album";
    </constructor>

   </implementation>
 
  </binding>




  <!-- TIME ELAPSED DISPLAY -->




  <binding id="timeelapsed-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.position.str";
    </constructor>

   </implementation>
 
  </binding>




  <!-- GENRE DISPLAY -->




  <binding id="genre-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      this.data  = "metadata.genre";
    </constructor>

   </implementation>
 
  </binding>




  <!-- CUSTOM DISPLAY -->



  <binding id="custom-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-compound-label">
  
  <implementation>

    <constructor>
      
      // this is a special version of a remote compound label, it takes its value from the preferences
      // and can be configured by the user from a preference pane
      
      this.setAttribute("value", SBDataGetStringValue("custom.display"));
    
    </constructor>

   </implementation>
 
  </binding>




  <!-- NUM PLAYLIST ITEMS DISPLAY -->




  <binding id="numplaylistitems-label" xextends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
    <content>
      <xul:hbox id="sb-player-numplaylistitems-label" flex="1" xbl:inherits="class">
        <xul:label id="sb-player-numplaylistitems-label-label" sbid="label" xbl:inherits="class,value,align,crop,disabled,flex"/> 
      </xul:hbox>
    </content>

    <implementation implements="nsIDOMEventListener,
                                sbIMediaListViewListener,
                                sbIMediaListListener,
                                nsISupportsWeakReference">
      <constructor>
        this.addListeners();
      </constructor>

      <destructor>
        this.removeListeners();
      </destructor>

      <method name="addListeners">
        <body>
          <![CDATA[
            var browser = window.gBrowser;
            if (browser) {
              browser.addEventListener("TabContentChange", this, false);
              browser.tabContainer.addEventListener("ScanProgressChange",
                                                    this, false);
            }
            else {
              let self = this;
              window.addEventListener("load",
                                      function() self.addListeners(), false);
            }
          ]]>
        </body>
      </method>

      <method name="removeListeners">
        <body>
          <![CDATA[
            var browser = window.gBrowser;
            if (browser) {
              browser.removeEventListener("TabContentChange", this, false);
              browser.tabContainer.removeEventListener("ScanProgressChange",
                                                       this, false);
            }

            if (this.previousMediaListView) {
              this.previousMediaListView.removeListener(this);
              this.previousMediaListView.mediaList.removeListener(this);
            }
          ]]>
        </body>
      </method>

      <field name="updateDisplayTimeout">null</field>
      <method name="updateDisplayAsync">
        <body>
          <![CDATA[
            // If we have changes following up in quick succession,
            // only update once and asynchronously
            if (this.updateDisplayTimeout)
              window.clearTimeout(this.updateDisplayTimeout);

            this.updateDisplayTimeout = window.setTimeout(function(that) {
              that.updateDisplayTimeout = null;
              that.updateDisplay();
            }, 1000, this);
          ]]>
        </body>
      </method>

      <method name="updateDisplay">
        <body>
          <![CDATA[
            var label = document.getAnonymousElementByAttribute(this, "sbid", "label");
            var displayValue = this.getAttribute('default');

            var browser = window.gBrowser;
            if (!browser) {
              label.setAttribute('value', displayValue);
              return;
            }

            if (browser.mCurrentTab.scanProgress >= 0 &&
                browser.mCurrentTab.scanProgress < 1) {
              // display page scan progress
              var mediafound = SBString("faceplate.mediafound", "Media Found");
              var percent = Math.round(browser.mCurrentTab.scanProgress*100);
              displayValue = mediafound + ': ' + percent + '%';
            } else if (browser.currentMediaListView != null) {
              var mediaListView = browser.currentMediaListView; 
              // HOORAY!!  It's okay for mediaListView.length to throw!
              var length = 0;
              try {
                length = mediaListView.length;
              } catch(e) {
                Components.utils.reportError(e);
                length = 0;
              }
              if ( length > 0 ) {
                // display media list length
                displayValue = SBFormattedCountString("faceplate.itemsformat",
                                                      length, [ length ], "");
              }
            }
            label.setAttribute('value', displayValue);
          ]]>
        </body>
      </method>

      <field name="previousMediaListView">null</field>

      <!-- nsIDOMEventListener -->
      <method name="handleEvent">
        <parameter name="event"/>
        <body>
          <![CDATA[
            if (event.type == "TabContentChange") {
              var browser = window.gBrowser;
              var mediaListView = (browser ? browser.currentMediaListView : null);
              if (mediaListView == this.previousMediaListView)
                return;

              if (this.previousMediaListView) {
                this.previousMediaListView.removeListener(this);
                this.previousMediaListView.mediaList.removeListener(this);
              }
              if (mediaListView) {
                const sbIML = Components.interfaces.sbIMediaList;
                mediaListView.addListener(this, true);
                mediaListView.mediaList.addListener(this, true,
                                                    sbIML.LISTENER_FLAGS_ITEMADDED |
                                                    sbIML.LISTENER_FLAGS_AFTERITEMREMOVED |
                                                    sbIML.LISTENER_FLAGS_LISTCLEARED |
                                                    sbIML.LISTENER_FLAGS_BATCHEND);
              }
              this.previousMediaListView = mediaListView;

              if (mediaListView)
                this.updateDisplayAsync();
              else
                this.updateDisplay();
            }
            else if (event.type == "ScanProgressChange") {
              // Scan status needs to be updated synchronously
              if (window.gBrowser && event.target == window.gBrowser.mCurrentTab)
                this.updateDisplay();
            }
          ]]>
        </body>
      </method>

      <!-- sbIMediaListViewListener -->
      <method name="onFilterChanged">
        <parameter name="changedView"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
      <method name="onSearchChanged">
        <parameter name="changedView"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
      <method name="onSortChanged">
        <parameter name="changedView"/>
        <body/>
      </method>

      <!-- sbIMediaListListener -->
      <method name="onItemAdded">
        <parameter name="mediaList"/>
        <parameter name="mediaItem"/>
        <parameter name="index"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
      <method name="onAfterItemRemoved">
        <parameter name="mediaList"/>
        <parameter name="mediaItem"/>
        <parameter name="index"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
      <method name="onListCleared">
        <parameter name="mediaList"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
      <method name="onBatchEnd">
        <parameter name="mediaList"/>
        <body>
          <![CDATA[
            this.updateDisplayAsync();
          ]]>
        </body>
      </method>
    </implementation>
 
  </binding>




  <!-- PLAYER SCANNING DISPLAY -->




  <binding id="scanning-label" extends="chrome://songbird/content/bindings/remoteLabel.xml#remote-label">
  
  <implementation>

    <constructor>
      <![CDATA[
        this.setAttribute( "hidden", "true" );
        this.data = "backscan.status";

        this.on_value_change = { 
          _that: null, 
          observe: function( aSubject, aTopic, aData ) { this._that.onValue( aData ); } 
        };
        this.on_value_change._that = this;
        this.bindvalue = SB_NewDataRemote("backscan.concurrent", null);
        this.bindvalue.bindObserver( this.on_value_change, false );
      ]]>
    </constructor>
    <destructor>
      <![CDATA[
        if (this.bindvalue) {
          this.bindvalue.unbind();
          this.bindvalue = null;
        }
      ]]>
    </destructor>
    
    <method name="onValue">
      <parameter name="aData"/>
      <body>
        <![CDATA[
          if ( parseInt( aData ) > 0  )
          {
            this.setAttribute( "hidden", "false" );
          }
          else
          {
            this.setAttribute( "hidden", "true" );
          }
        ]]>
      </body>
    </method>
    
   </implementation>
 
  </binding>
  
  
  
  <!-- JUMP TO CURRENT TRACK BUTTON -->
  
  <binding id="curtrack-base">
    
    <implementation>
      
      <method name="getBrowser">
        <body>
          <![CDATA[
            var retval = null;
            try {
              // Dig through the parent chain to find a happy gBrowser.
              for ( var win = window; 
                    win != null && win != win.parent && 
                    typeof win.gBrowser == 'undefined'; 
                    win = win.parent ) ; // Yes, it is there on purpose.
              if ( win ) {
                retval = win.gBrowser;
              }
            } catch(e) {}
            return retval;
          ]]>
        </body>
      </method>
          
      <method name="onCurrentTrack">
        <body>
          <![CDATA[
            goDoCommand('cmd_find_current_track');
          ]]>
        </body>
      </method>
    </implementation>
  </binding>

  <binding id="curtrack-button" extends="chrome://songbird/content/bindings/playerControls.xml#curtrack-base">
    
    <content>
      <xul:hbox id="sb-player-curtrack-button" flex="1" xbl:inherits="hidden,class">
        <xul:button type="sb-clickhold"
                    id="sb-player-curtrack-button-button"
                    oncommand="onCurrentTrack( );"
                    class="sb-player-curtrack-button sb-player-button"
                    tooltiptext="&tooltip.control.curtrack;"
                    xbl:inherits="label,position">
          <xul:menupopup xbl:inherits="popupanchor,popupalign"/>
        </xul:button>
      </xul:hbox>
    </content>

  </binding>
  
  <binding id="curtrack-box" extends="chrome://songbird/content/bindings/playerControls.xml#curtrack-base">
    
    <content>
      <xul:box id="sb-player-curtrack-box" 
                orient="horizontal" 
                mousethrough="never" 
                onclick="if (event.button == 0) onCurrentTrack();" 
                xbl:inherits="hidden,class,flex,pack,orient">
        <children/>
      </xul:box>
    </content>

  </binding>
  
  
  
   
  <!-- TOGGLE JUMP TO WINDOW -->
  
  <binding id="jumpto-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">
    
    <handlers>
      <handler event="command" action="this.onCommand();"/>
    </handlers>
    
    <implementation>
    
      <constructor>
        this.setAttribute("tooltiptext", "&jumptofile.title;")
      </constructor>
      
      <method name="onCommand">
        <body>
          <![CDATA[
            // At this point there isn't much we can do other than hope that
            // jumpToFile.js has been included in the window
            // TODO this will need to change once jumptofile has been refactored
            try {
              toggleJumpTo();
            } catch (e) {
              var msg = "sb-player-jumpto-button: unable to call toggleJumpTo.\n" +
                        "Please make sure this window includes jumpToFile.js.\n";
              dump(msg);
              Components.utils.reportError(msg);
            }
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>


  <!-- ENTER FULLSCREEN MODE (WHEN PLAYING VIDEO) -->
  
  <binding id="fullscreen-button" extends="chrome://songbird/content/bindings/playerControls.xml#sb-button-base">
    
    <handlers>
      <handler event="command" action="this.onCommand();"/>
    </handlers>
    
    <implementation>
    
      <constructor>
        this.setAttribute("tooltiptext", "&tooltip.fullscreen;");
        
        // Mac fullscreen coming soon.
        var sysInfo = Components.classes["@mozilla.org/system-info;1"]
                                .getService(Components.interfaces.nsIPropertyBag2);
        if ( sysInfo.getProperty("name") == "Darwin" ) {
          this.setAttribute("hidden", "true");
        }
      </constructor>
      
      <method name="onCommand">
        <body>
          <![CDATA[
            // XXXAus: Reimplement this when we have video enabled using the new
            //         mediacore api.
          ]]>
        </body>
      </method>
      
    </implementation>
  </binding>
  

  
  
  <!-- EOF -->
</bindings>
