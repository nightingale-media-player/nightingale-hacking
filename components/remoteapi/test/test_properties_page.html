<!--
/*
 //
// BEGIN SONGBIRD GPL
//
// This file is part of the Songbird web player.
//
// Copyright(c) 2005-2007 POTI, Inc.
// http://songbirdnest.com
//
// This file may be licensed under the terms of of the
// GNU General Public License Version 2 (the "GPL").
//
// Software distributed under the License is distributed
// on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either
// express or implied. See the GPL for the specific language
// governing rights and limitations.
//
// You should have received a copy of the GPL along with this
// program. If not, go to http://www.gnu.org/licenses/gpl.html
// or write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
//
// END SONGBIRD GPL
//
 */
-->
<html>
  <head>
    <script>
function runTest(tester) {
  try {
    // All the standard properties
    var props = tester.props;

    // must have a value that will parse to a number
    var numericalPropNames = [
      "ordinal",
      "contentLength",
      "trackNumber",
      "discNumber",
      "totalDiscs",
      "totalTracks",
      "playCount",
      "skipCount",
      "rating",                     // value [0-5]
      "duration",
      "lastPlayTime"
    ];

    // must have a uri-valid value
    var uriPropNames = [
      "albumArtURL",
      "originURL"
    ];

    // this one is just super special
    var specialNames = [
      "year"                        // 1877 min value
    ];

    // boolean value
    var booleanPropNames = [
      "hidden",                     // boolean  1/0
      "isPartOfCompilation",        // boolean  1/0
      "enableAutoDownload"          // boolean  1/0
    ];

    // These we can't read from the WPAIP
    // contentURL is special cased down below.
    var nonRemoteReadableNames = [
      "rapiScopeURL",
      "created",
      "updated",
      "GUID",
      "storageGUID",
      "ordinal",
      "contentMimeType",
      "contentLength",
      "isList",
      "rapiSiteURL",
      "customType",
      "destination",
      "isSortable"
    ];

    // These we can't modify from the WPAPI
    var nonRemoteWritableNames = [
      "rapiScopeURL",
      "contentURL",
      "created",
      "updated",
      "GUID",
      "storageGUID",
      "ordinal",
      "contentMimeType",
      "contentLength",
      "playCount",
      "skipCount",
      "isList",
      "customType",
      "destination",
      "downloadStatusTarget",
      "rapiSiteURL",
      "rapiSiteID",
      "isSortable",
      "originPage",
      "originPageTitle",
      "lastPlayTime",
      "lastSkipTime",
      "originURL"
    ];

    var library = songbird.mainLibrary;
    var list = library.createSimpleMediaList("TestList");
    var item = library.createMediaItem("http://example.com/foo");

    var sitelibrary = songbird.siteLibrary;
    var sitelist = sitelibrary.createSimpleMediaList("TestSiteList");
    var siteitem = sitelibrary.createMediaItem("http://example.com/foo");

    var testObjs = { sitelibrary: sitelibrary,
                     sitelist: sitelist,
                     siteitem: siteitem,
                     library: library,
                     list: list,
                     item: item };

    for ( var obj in testObjs ) {
      var foo = testObjs[obj];

      tester.log("");
      tester.log("---------------------------------------------------");
      tester.log("                  " + obj);
      tester.log("---------------------------------------------------");

      tester.log("");
      tester.log("Writing to the properties");
      tester.log("");

      // loop over all stuff in props to make sure we don't miss anything
      for ( var stuff in props ) {

        // check that we can't write to properties we aren't supposed
        // to have write access for.
        if ( nonRemoteWritableNames.indexOf(stuff) > -1 ) {
          try {
            foo.setProperty( props[stuff], "FAIL" );
            tester.fail( "property (!w)\t" + stuff +
                         " ERR: writable when not supposed to be" );
          } catch (e) {
            // could not write to a property - SUCCESS
            tester.log( "property (!w)\t" + stuff );
          }
          continue;
        }

        // Everything else is writable, no test for write only
        tester.log( "property ( w)\t" + stuff );

        // year has a min value
        if ( stuff == "year" ) {
          foo.setProperty( props[stuff], "1877" );
        }
        // these properties get a number
        else if ( numericalPropNames.indexOf(stuff) > -1 ) {
          foo.setProperty( props[stuff], "4" );
        }
        // these get special numbers
        else if ( booleanPropNames.indexOf(stuff) > -1 ) {
          foo.setProperty( props[stuff], "1" );
        }
        // these get url format strings
        else if ( uriPropNames.indexOf(stuff) > -1 ) {
          foo.setProperty( props[stuff], "http://example.com/foo" );
        }
        // everything else gets a test string
        else {
          foo.setProperty( props[stuff], "test" );
        }
      }

      tester.log("");
      tester.log("Reading the properties");
      tester.log("");

      // loop over all stuff in props to make sure we don't miss anything
      for ( var stuff in props ) {

        // report the non-readable names
        if ( nonRemoteReadableNames.indexOf(stuff) > -1 ) {
          try {
            foo.getProperty( props[stuff] );
            tester.fail( "property (!r)\t" + stuff +
                         " ERR: Was able to read non-readable property:" );
          } catch (e) {
            // couldn't read from a property we shouldn't be able to read
            tester.log( "property (!r)\t" + stuff );
          }
          continue;
        }

        if ( stuff == "contentURL" ) {
          // special case the contentURL for its different settings and
          // behavior.
          // We should be able to read
          // the contentURL for list and item provided they aren't file: and
          // currently the list is songbird-medialist:// and the file is 
          // created above as http: If library becomes a songbird-library::
          // url this test will break and need fixing.
          try {
            // for non-file siteitems and sitelists
            var val = foo.getProperty(props[stuff]);
            if ( obj == "sitelist" || obj == "siteitem" ) {
              tester.log( "property (ro)\t" + stuff + " is: " + val );
            } else {
              tester.fail( "property (ro)\t" + stuff +
                           " ERR: Able to read library contentURL" );
            }
          } catch (e) {
            // for sitelibraries - their contentURL is file:
            // all other mainlib stuff can't access contentURL
            if ( obj == "sitelibrary" ||
                 obj == "library" ||
                 obj == "list" ||
                 obj == "item" ) {
              tester.log( "property (!r)\t" + stuff );
            } else {
              tester.fail( "property (!r)\t" + stuff +
                           " ERR: Not able to read list/item contentURL" );
            }
          }
          continue;
        }

        // We couldn't write to this properties so just check we can get them
        if ( nonRemoteWritableNames.indexOf(stuff) > -1 ) {
          try {
            foo.getProperty( props[stuff] );
            tester.log( "property (ro)\t" + stuff );
          } catch (e) {
            tester.fail( "property (ro)\t" + stuff +
                         " ERR: Not actually readable" );
          }
          // continue because the following asserts will fail since we didn't
          // write anything into them above, they're read only.
          continue;
        }

        tester.log( "property ( r)\t" + stuff );

        // year has a min value
        if ( stuff == "year" ) {
          tester.assertEqual( foo.getProperty(props[stuff]), "1877" );
        }
        // these properties get a number
        else if ( numericalPropNames.indexOf(stuff) > -1 ) {
          tester.assertEqual( foo.getProperty( props[stuff] ), "4" );
        }
        // these get special numbers
        else if ( booleanPropNames.indexOf(stuff) > -1 ) {
          tester.assertEqual( foo.getProperty(props[stuff] ), "1" );
        }
        // these get url format strings
        else if ( uriPropNames.indexOf(stuff) > -1 ) {
          tester.assertEqual( foo.getProperty( props[stuff] ),
                              "http://example.com/foo" );
        }
        // everything else gets a test string
        else {
          tester.assertEqual( foo.getProperty( props[stuff] ), "test" );
        }
      }
    }

  } catch (e) {
    tester.endRemoteAPITest(e);
  }

  songbird.downloadMediaList.clear();

  tester.endRemoteAPITest();
}

/*
function assertStringArray( tester, a, e ) {
  while ( e.hasMore() ) {
    var s = e.getNext();
    var i = a.indexOf(s);
    if ( i < 0 ) {
      tester.fail( "String '" + s + "' not in array" );
    }
    a.splice( i, 1 );
  }
  if ( a.length > 0 ) {
    tester.fail("Array contains stuff the enumerator did not: " + a);
  }
}

function enumeratorToArray(e) {
  var a = [];
  while (e.hasMoreElements()) {
    a.push(e.getNext());
  }
  return a;
}

function assertItemArray(tester, a, e) {
  while (e.hasMoreElements()) {
    var item = e.getNext();
    var i = -1;
    for (var j = 0; j < a.length; j++) {
      if (a[j].equals(item)) {
        i = j;
      }
    }
    if (i < 0) {
      tester.fail("Item '" + item.guid + "' not in array");
    }
    a.splice(i, 1);
  }
  if (a.length > 0) {
    var guids = [];
    for (var i = 0; i < a.length; i++) {
      guids.push(a[i].guid);
    }
    tester.fail("Array contains stuff the enumerator did not: " + guids);
  }
}
*/


function runPageTest(tester) {
  setTimeout( function runPageTest_setTimeout() { runTest(tester) }, 0 );
}
    </script>
  </head>
  <body>test_remotelibrary_getters_page.html</body>
</html>

